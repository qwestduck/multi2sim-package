Description: Disable clcc which depends on the currently unpackaged AMDAPP SDK
 AMDAPP SDK 2.5 contains a specific version of libOpenCL.so that clcc depends
 on, but AMDAPP SDK 2.5 currently is not packaged in either Debian or Ubuntu.
 clcc is a non-critical component of the multi2sim package so it can be disabled
 (not compiled) until its dependencies have been packaged.
 .
 multi2sim (4.1+svn20130603-1) unstable; urgency=low
 .
   * Disable clcc until amdapp is packaged
Author: William Panlener <wpanlener@gmail.com>
Last-Update: <2013-06-03>
---

--- /dev/null
+++ multi2sim-4.1+svn20130603/tools/clcc/si2bin/parser.c
@@ -0,0 +1,2396 @@
+/* A Bison parser, made by GNU Bison 2.5.  */
+
+/* Bison implementation for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.5"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse         si2bin_yyparse
+#define yylex           si2bin_yylex
+#define yyerror         si2bin_yyerror
+#define yylval          si2bin_yylval
+#define yychar          si2bin_yychar
+#define yydebug         si2bin_yydebug
+#define yynerrs         si2bin_yynerrs
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 268 of yacc.c  */
+#line 20 "parser.y"
+
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <arch/southern-islands/asm/arg.h>
+#include <lib/util/debug.h>
+#include <lib/util/elf-encode.h>
+#include <lib/util/hash-table.h>
+#include <lib/util/list.h>
+#include <lib/util/string.h>
+
+#include "arg.h"
+#include "inner-bin.h"
+#include "id.h"
+#include "inst.h"
+#include "metadata.h"
+#include "outer-bin.h"
+#include "si2bin.h"
+#include "string.h"
+#include "symbol.h"
+#include "task.h"
+
+
+#define YYERROR_VERBOSE
+
+
+/* 'si2bin_inner_bin' and 'si2bin_inner_bin_entry' pointing to the current internal
+ * binary that is set every time a new .global section is found. */
+
+struct si2bin_inner_bin_t *si2bin_inner_bin;
+struct si2bin_metadata_t *si2bin_metadata;
+int si2bin_uniqueid = 1024;
+
+
+
+
+/* Line 268 of yacc.c  */
+#line 119 "parser.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     TOK_SCALAR_REGISTER = 258,
+     TOK_VECTOR_REGISTER = 259,
+     TOK_SPECIAL_REGISTER = 260,
+     TOK_DECIMAL = 261,
+     TOK_HEX = 262,
+     TOK_FLOAT = 263,
+     TOK_ID = 264,
+     TOK_COMMA = 265,
+     TOK_COLON = 266,
+     TOK_FORMAT = 267,
+     TOK_OFFEN = 268,
+     TOK_IDXEN = 269,
+     TOK_OFFSET = 270,
+     TOK_OBRA = 271,
+     TOK_CBRA = 272,
+     TOK_OPAR = 273,
+     TOK_CPAR = 274,
+     TOK_NEW_LINE = 275,
+     TOK_AMP = 276,
+     TOK_ABS = 277,
+     TOK_NEG = 278,
+     TOK_STAR = 279,
+     TOK_GLOBAL = 280,
+     TOK_MEM = 281,
+     TOK_ARGS = 282,
+     TOK_DATA = 283,
+     TOK_TEXT = 284
+   };
+#endif
+/* Tokens.  */
+#define TOK_SCALAR_REGISTER 258
+#define TOK_VECTOR_REGISTER 259
+#define TOK_SPECIAL_REGISTER 260
+#define TOK_DECIMAL 261
+#define TOK_HEX 262
+#define TOK_FLOAT 263
+#define TOK_ID 264
+#define TOK_COMMA 265
+#define TOK_COLON 266
+#define TOK_FORMAT 267
+#define TOK_OFFEN 268
+#define TOK_IDXEN 269
+#define TOK_OFFSET 270
+#define TOK_OBRA 271
+#define TOK_CBRA 272
+#define TOK_OPAR 273
+#define TOK_CPAR 274
+#define TOK_NEW_LINE 275
+#define TOK_AMP 276
+#define TOK_ABS 277
+#define TOK_NEG 278
+#define TOK_STAR 279
+#define TOK_GLOBAL 280
+#define TOK_MEM 281
+#define TOK_ARGS 282
+#define TOK_DATA 283
+#define TOK_TEXT 284
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 293 of yacc.c  */
+#line 60 "parser.y"
+
+	int num;
+	float num_float;
+	struct si2bin_id_t *id;
+	struct si2bin_inst_t *inst;
+	struct si_label_t *label;
+	struct list_t *list;
+	struct si2bin_arg_t *arg;
+
+
+
+/* Line 293 of yacc.c  */
+#line 225 "parser.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 343 of yacc.c  */
+#line 237 "parser.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  9
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   119
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  30
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  31
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  65
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  113
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   284
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     5,     8,    10,    13,    16,    18,    21,
+      23,    25,    27,    29,    33,    35,    38,    41,    43,    46,
+      55,    57,    60,    63,    65,    68,    70,    72,    75,    78,
+      80,    83,    87,    92,    99,   101,   104,   107,   109,   112,
+     115,   118,   121,   124,   125,   127,   131,   133,   135,   137,
+     139,   141,   143,   145,   152,   157,   160,   170,   172,   174,
+     175,   178,   181,   186,   188,   192
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      31,     0,    -1,    32,    -1,    20,    32,    -1,    33,    -1,
+      33,    32,    -1,    36,    34,    -1,    35,    -1,    35,    34,
+      -1,    37,    -1,    41,    -1,    45,    -1,    49,    -1,    25,
+       9,    20,    -1,    38,    -1,    38,    39,    -1,    26,    20,
+      -1,    40,    -1,    40,    39,    -1,     9,     9,    16,     6,
+      11,     6,    17,    20,    -1,    42,    -1,    42,    43,    -1,
+      28,    20,    -1,    44,    -1,    44,    43,    -1,    20,    -1,
+      46,    -1,    46,    47,    -1,    27,    20,    -1,    48,    -1,
+      48,    47,    -1,     9,     6,    20,    -1,     9,    24,     6,
+      20,    -1,     9,    16,     6,    17,     6,    20,    -1,    50,
+      -1,    50,    51,    -1,    29,    20,    -1,    52,    -1,    52,
+      51,    -1,    53,    20,    -1,    54,    20,    -1,     9,    11,
+      -1,     9,    55,    -1,    -1,    57,    -1,    57,    10,    55,
+      -1,     3,    -1,     4,    -1,     5,    -1,     6,    -1,     7,
+      -1,     8,    -1,    56,    -1,     9,    16,     6,    11,     6,
+      17,    -1,    22,    18,    57,    19,    -1,    23,    57,    -1,
+      56,    58,    12,    11,    16,     9,    10,     9,    17,    -1,
+       9,    -1,    59,    -1,    -1,    58,    13,    -1,    58,    14,
+      -1,    58,    15,    11,     6,    -1,    60,    -1,    60,    21,
+      59,    -1,     9,    18,     6,    19,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   113,   113,   114,   118,   119,   123,   127,   128,   132,
+     133,   134,   135,   139,   158,   159,   163,   167,   168,   172,
+     212,   213,   217,   221,   222,   226,   230,   231,   235,   239,
+     240,   245,   264,   286,   310,   311,   315,   319,   320,   324,
+     326,   339,   366,   387,   391,   405,   418,   424,   430,   436,
+     441,   450,   457,   462,   501,   525,   549,   574,   597,   606,
+     610,   621,   632,   645,   647,   671
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "TOK_SCALAR_REGISTER",
+  "TOK_VECTOR_REGISTER", "TOK_SPECIAL_REGISTER", "TOK_DECIMAL", "TOK_HEX",
+  "TOK_FLOAT", "TOK_ID", "TOK_COMMA", "TOK_COLON", "TOK_FORMAT",
+  "TOK_OFFEN", "TOK_IDXEN", "TOK_OFFSET", "TOK_OBRA", "TOK_CBRA",
+  "TOK_OPAR", "TOK_CPAR", "TOK_NEW_LINE", "TOK_AMP", "TOK_ABS", "TOK_NEG",
+  "TOK_STAR", "TOK_GLOBAL", "TOK_MEM", "TOK_ARGS", "TOK_DATA", "TOK_TEXT",
+  "$accept", "program", "kernel_list", "kernel", "section_list", "section",
+  "global_section", "mem_section", "mem_header", "mem_stmt_list",
+  "mem_stmt", "data_section", "data_header", "data_stmt_list", "data_stmt",
+  "args_section", "args_header", "args_stmt_list", "args_stmt",
+  "text_section", "text_header", "text_stmt_list", "text_stmt", "label",
+  "instr", "arg_list", "operand", "arg", "maddr_qual", "waitcnt_arg",
+  "waitcnt_elem", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    30,    31,    31,    32,    32,    33,    34,    34,    35,
+      35,    35,    35,    36,    37,    37,    38,    39,    39,    40,
+      41,    41,    42,    43,    43,    44,    45,    45,    46,    47,
+      47,    48,    48,    48,    49,    49,    50,    51,    51,    52,
+      52,    53,    54,    55,    55,    55,    56,    56,    56,    56,
+      56,    56,    57,    57,    57,    57,    57,    57,    57,    58,
+      58,    58,    58,    59,    59,    60
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     2,     1,     2,     2,     1,     2,     1,
+       1,     1,     1,     3,     1,     2,     2,     1,     2,     8,
+       1,     2,     2,     1,     2,     1,     1,     2,     2,     1,
+       2,     3,     4,     6,     1,     2,     2,     1,     2,     2,
+       2,     2,     2,     0,     1,     3,     1,     1,     1,     1,
+       1,     1,     1,     6,     4,     2,     9,     1,     1,     0,
+       2,     2,     4,     1,     3,     4
+};
+
+/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,     0,     0,     0,     2,     4,     0,     3,     0,     1,
+       5,     0,     0,     0,     0,     6,     7,     9,    14,    10,
+      20,    11,    26,    12,    34,    13,    16,    28,    22,    36,
+       8,     0,    15,    17,    25,    21,    23,     0,    27,    29,
+      43,    35,    37,     0,     0,     0,    18,    24,     0,     0,
+       0,    30,    46,    47,    48,    49,    50,    51,    57,    41,
+       0,     0,    42,    59,    44,    58,    63,    38,    39,    40,
+       0,    31,     0,     0,     0,     0,     0,    55,     0,    43,
+       0,     0,     0,    32,     0,     0,     0,     0,    60,    61,
+       0,    45,     0,    64,     0,     0,     0,    65,    54,     0,
+       0,     0,    33,     0,     0,    62,     0,    53,     0,    19,
+       0,     0,    56
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     3,     4,     5,    15,    16,     6,    17,    18,    32,
+      33,    19,    20,    35,    36,    21,    22,    38,    39,    23,
+      24,    41,    42,    43,    44,    62,    63,    64,    78,    65,
+      66
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -46
+static const yytype_int8 yypact[] =
+{
+       2,    -7,    12,    24,   -46,    -7,     8,   -46,    22,   -46,
+     -46,    28,    29,    30,    31,   -46,     8,   -46,    35,   -46,
+      32,   -46,    37,   -46,    38,   -46,   -46,   -46,   -46,   -46,
+     -46,    44,   -46,    35,   -46,   -46,    32,     1,   -46,    37,
+      -3,   -46,    38,    34,    36,    39,   -46,   -46,    40,    51,
+      52,   -46,   -46,   -46,   -46,   -46,   -46,   -46,    27,   -46,
+      41,     6,   -46,    13,    53,   -46,    43,   -46,   -46,   -46,
+      55,   -46,    45,    46,    59,    61,     6,   -46,    26,     6,
+      60,    57,    64,   -46,    62,    56,    58,    63,   -46,   -46,
+      65,   -46,    54,   -46,    72,    66,    73,   -46,   -46,    67,
+      74,    68,   -46,    70,    75,   -46,    69,   -46,    71,   -46,
+      79,    76,   -46
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -46,   -46,    25,   -46,    78,   -46,   -46,   -46,   -46,    49,
+     -46,   -46,   -46,    77,   -46,   -46,   -46,    80,   -46,   -46,
+     -46,    48,   -46,   -46,   -46,    -8,   -46,   -45,   -46,    11,
+     -46
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -53
+static const yytype_int8 yytable[] =
+{
+      52,    53,    54,    55,    56,    57,    58,    48,    59,    52,
+      53,    54,    55,    56,    57,    58,    77,    49,     2,    60,
+      61,     8,     1,   -52,     9,    50,     7,     2,    60,    61,
+      10,    86,   -52,   -52,    11,    12,    13,    14,    87,    88,
+      89,    90,    25,    74,    31,    75,    37,    40,    26,    27,
+      28,    29,    34,    45,    68,    70,    69,    72,    73,    76,
+      71,    81,    82,    79,    80,    84,    83,    85,    94,    92,
+      95,    91,    75,    96,    99,    97,   100,    98,   101,   103,
+     105,   110,    46,   104,   108,   106,   102,   107,   111,   109,
+      67,    93,     0,   112,    30,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    47,     0,     0,     0,     0,     0,    51
+};
+
+#define yypact_value_is_default(yystate) \
+  ((yystate) == (-46))
+
+#define yytable_value_is_error(yytable_value) \
+  YYID (0)
+
+static const yytype_int8 yycheck[] =
+{
+       3,     4,     5,     6,     7,     8,     9,     6,    11,     3,
+       4,     5,     6,     7,     8,     9,    61,    16,    25,    22,
+      23,     9,    20,    10,     0,    24,     1,    25,    22,    23,
+       5,    76,    19,    20,    26,    27,    28,    29,    12,    13,
+      14,    15,    20,    16,     9,    18,     9,     9,    20,    20,
+      20,    20,    20,     9,    20,    16,    20,     6,     6,    18,
+      20,     6,    17,    10,    21,     6,    20,     6,    11,     9,
+       6,    79,    18,    11,    11,    19,    11,    19,     6,     6,
+       6,    10,    33,    16,     9,    17,    20,    17,     9,    20,
+      42,    80,    -1,    17,    16,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    36,    -1,    -1,    -1,    -1,    -1,    39
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    20,    25,    31,    32,    33,    36,    32,     9,     0,
+      32,    26,    27,    28,    29,    34,    35,    37,    38,    41,
+      42,    45,    46,    49,    50,    20,    20,    20,    20,    20,
+      34,     9,    39,    40,    20,    43,    44,     9,    47,    48,
+       9,    51,    52,    53,    54,     9,    39,    43,     6,    16,
+      24,    47,     3,     4,     5,     6,     7,     8,     9,    11,
+      22,    23,    55,    56,    57,    59,    60,    51,    20,    20,
+      16,    20,     6,     6,    16,    18,    18,    57,    58,    10,
+      21,     6,    17,    20,     6,     6,    57,    12,    13,    14,
+      15,    55,     9,    59,    11,     6,    11,    19,    19,    11,
+      11,     6,    20,     6,    16,     6,    17,    17,     9,    20,
+      10,     9,    17
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
+
+#define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* This macro is provided for backward compatibility. */
+
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  YYSIZE_T yysize1;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = 0;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - Assume YYFAIL is not used.  It's too flawed to consider.  See
+       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
+       for details.  YYERROR is fine as it does not invoke this
+       function.
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+                if (! (yysize <= yysize1
+                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                  return 2;
+                yysize = yysize1;
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  yysize1 = yysize + yystrlen (yyformat);
+  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+    return 2;
+  yysize = yysize1;
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 13:
+
+/* Line 1806 of yacc.c  */
+#line 140 "parser.y"
+    {
+		struct si2bin_id_t *id = (yyvsp[(2) - (3)].id);
+
+		si2bin_inner_bin = si2bin_inner_bin_create(id->name);
+		si2bin_metadata = si2bin_metadata_create();
+		si2bin_entry = si2bin_inner_bin_entry_create();
+
+		si2bin_metadata->uniqueid = si2bin_uniqueid;
+
+		si2bin_inner_bin_add_entry(si2bin_inner_bin, si2bin_entry);
+		si2bin_outer_bin_add(si2bin_outer_bin, si2bin_inner_bin, si2bin_metadata);
+
+		si2bin_uniqueid ++;
+		
+		si2bin_id_free(id);
+	}
+    break;
+
+  case 19:
+
+/* Line 1806 of yacc.c  */
+#line 173 "parser.y"
+    {
+		struct si2bin_id_t *id = (yyvsp[(1) - (8)].id);
+		struct si2bin_inner_bin_constant_buffer_t *cb;
+
+		
+		if (!strcmp(id->name, "uav"))
+		{
+			si2bin_inner_bin->uav_ptr->start_reg = (yyvsp[(4) - (8)].num);
+			si2bin_inner_bin->uav_ptr->end_reg = (yyvsp[(6) - (8)].num);
+		}
+		else if (!strcmp(id->name, "cb0"))
+		{
+			cb = list_get(si2bin_inner_bin->cb_list, 0);
+			assert(cb);
+			cb->start_reg = (yyvsp[(4) - (8)].num);
+			cb->end_reg = (yyvsp[(6) - (8)].num);
+		}
+		else if (!strcmp(id->name, "cb1"))
+		{
+			cb = list_get(si2bin_inner_bin->cb_list, 1);
+			assert(cb);
+			cb->start_reg = (yyvsp[(4) - (8)].num);
+			cb->end_reg = (yyvsp[(6) - (8)].num);
+		}
+		else if (!strcmp(id->name, "cb2"))
+		{
+			cb = list_get(si2bin_inner_bin->cb_list, 2);
+			assert(cb);
+			cb->start_reg = (yyvsp[(4) - (8)].num);
+			cb->end_reg = (yyvsp[(6) - (8)].num);
+		}
+
+		si2bin_id_free(id);
+		si2bin_id_free((yyvsp[(2) - (8)].id));
+	}
+    break;
+
+  case 31:
+
+/* Line 1806 of yacc.c  */
+#line 246 "parser.y"
+    {
+		struct si2bin_id_t *id;
+		struct si_arg_t *arg;
+		int data_type;
+
+		id = (yyvsp[(1) - (3)].id);
+
+		data_type = str_map_string(&si_arg_data_type_map, id->name);
+		arg = si_arg_create(si_arg_value, "val");
+		arg->value.data_type = data_type;
+		arg->value.num_elems = 1;
+		arg->value.constant_buffer_num = 1;
+		arg->value.constant_offset = (yyvsp[(2) - (3)].num);
+		
+		si2bin_metadata_add_arg(si2bin_metadata, arg);
+
+		si2bin_id_free(id);
+	}
+    break;
+
+  case 32:
+
+/* Line 1806 of yacc.c  */
+#line 265 "parser.y"
+    {
+		struct si2bin_id_t *id;
+		struct si_arg_t *arg;
+		int data_type;
+
+		id = (yyvsp[(1) - (4)].id);
+
+		data_type = str_map_string(&si_arg_data_type_map, id->name);
+		arg = si_arg_create(si_arg_pointer, "ptr");
+		arg->pointer.data_type = data_type;
+		arg->pointer.constant_buffer_num = 1;
+		arg->pointer.constant_offset = (yyvsp[(3) - (4)].num);
+		arg->pointer.scope = si_arg_uav;
+		arg->pointer.buffer_num = 12;
+		arg->pointer.access_type = si_arg_read_write;
+		
+		si2bin_metadata_add_arg(si2bin_metadata, arg);
+
+		si2bin_id_free(id);
+		id = (yyvsp[(1) - (4)].id);
+	}
+    break;
+
+  case 33:
+
+/* Line 1806 of yacc.c  */
+#line 287 "parser.y"
+    {
+		struct si2bin_id_t *id;
+		struct si_arg_t *arg;
+		int data_type;
+
+		id = (yyvsp[(1) - (6)].id);
+
+		data_type = str_map_string(&si_arg_data_type_map, id->name);
+		arg = si_arg_create(si_arg_value, "val");
+		arg->value.data_type = data_type;
+		arg->value.num_elems = (yyvsp[(3) - (6)].num);
+		arg->value.constant_buffer_num = 1;
+		arg->value.constant_offset = (yyvsp[(5) - (6)].num);
+		
+		si2bin_metadata_add_arg(si2bin_metadata, arg);
+
+		si2bin_id_free(id);
+	}
+    break;
+
+  case 40:
+
+/* Line 1806 of yacc.c  */
+#line 327 "parser.y"
+    {
+		struct si2bin_inst_t *inst = (yyvsp[(1) - (2)].inst);
+
+		/* Generate code */
+		si2bin_inst_gen(inst);
+		elf_enc_buffer_write(si2bin_entry->text_section_buffer, inst->inst_bytes.bytes, inst->size);
+		si2bin_inst_dump(inst, stdout);
+		si2bin_inst_free(inst);
+	}
+    break;
+
+  case 41:
+
+/* Line 1806 of yacc.c  */
+#line 340 "parser.y"
+    {
+		struct si2bin_id_t *id = (yyvsp[(1) - (2)].id);
+		struct si2bin_symbol_t *symbol;
+
+		
+		/* Check if symbol exists */
+		symbol = hash_table_get(si2bin_symbol_table, id->name);
+		if (symbol && symbol->defined)
+			si2bin_yyerror_fmt("multiply defined label: %s", id->name);
+
+		/* Create if it does not exists */
+		if (!symbol)
+		{
+			symbol = si2bin_symbol_create(id->name);
+			hash_table_insert(si2bin_symbol_table, id->name, symbol);
+		}
+
+		/* Define symbol */
+		symbol->defined = 1;
+		symbol->value = si2bin_entry->text_section_buffer->offset;		
+
+		/* End */
+		si2bin_id_free(id);
+	}
+    break;
+
+  case 42:
+
+/* Line 1806 of yacc.c  */
+#line 367 "parser.y"
+    {
+		struct si2bin_inst_t *inst;
+		struct si2bin_id_t *id;
+		struct list_t *arg_list;
+
+		/* Get arguments */
+		id = (yyvsp[(1) - (2)].id);
+		arg_list = (yyvsp[(2) - (2)].list);
+		
+		/* Create instruction */
+		inst = si2bin_inst_create(id->name, arg_list);
+
+		/* Return instructions */
+		si2bin_id_free(id);
+		(yyval.inst) = inst;
+	}
+    break;
+
+  case 43:
+
+/* Line 1806 of yacc.c  */
+#line 387 "parser.y"
+    {
+		(yyval.list) = NULL;
+	}
+    break;
+
+  case 44:
+
+/* Line 1806 of yacc.c  */
+#line 392 "parser.y"
+    {
+		struct list_t *arg_list;
+		
+		/* Create */
+		arg_list = list_create();
+		
+		/* Initialize */
+		list_add(arg_list, (yyvsp[(1) - (1)].arg));
+		
+		/* Return the arg list */
+		(yyval.list) = arg_list;
+	}
+    break;
+
+  case 45:
+
+/* Line 1806 of yacc.c  */
+#line 406 "parser.y"
+    {
+		/* Add argument to head of list_t in $3 */
+		list_insert((yyvsp[(3) - (3)].list), 0, (yyvsp[(1) - (3)].arg));
+		
+		/* Return the arg list */
+		(yyval.list) = (yyvsp[(3) - (3)].list);
+
+	}
+    break;
+
+  case 46:
+
+/* Line 1806 of yacc.c  */
+#line 419 "parser.y"
+    {
+		(yyval.arg) = si2bin_arg_create_scalar_register((yyvsp[(1) - (1)].id)->name);
+		si2bin_id_free((yyvsp[(1) - (1)].id));
+	}
+    break;
+
+  case 47:
+
+/* Line 1806 of yacc.c  */
+#line 425 "parser.y"
+    {
+		(yyval.arg) = si2bin_arg_create_vector_register((yyvsp[(1) - (1)].id)->name); 
+		si2bin_id_free((yyvsp[(1) - (1)].id));
+	}
+    break;
+
+  case 48:
+
+/* Line 1806 of yacc.c  */
+#line 431 "parser.y"
+    {
+		(yyval.arg) = si2bin_arg_create_special_register((yyvsp[(1) - (1)].id)->name); 
+		si2bin_id_free((yyvsp[(1) - (1)].id));
+	}
+    break;
+
+  case 49:
+
+/* Line 1806 of yacc.c  */
+#line 437 "parser.y"
+    {
+		(yyval.arg) = si2bin_arg_create_literal((yyvsp[(1) - (1)].num));
+	}
+    break;
+
+  case 50:
+
+/* Line 1806 of yacc.c  */
+#line 442 "parser.y"
+    {
+		int value;
+
+		sscanf((yyvsp[(1) - (1)].id)->name, "%x", &value);
+		(yyval.arg) = si2bin_arg_create_literal(value); 
+		si2bin_id_free((yyvsp[(1) - (1)].id));
+	}
+    break;
+
+  case 51:
+
+/* Line 1806 of yacc.c  */
+#line 451 "parser.y"
+    {
+		(yyval.arg) = si2bin_arg_create_literal_float((yyvsp[(1) - (1)].num_float));
+	}
+    break;
+
+  case 52:
+
+/* Line 1806 of yacc.c  */
+#line 458 "parser.y"
+    {
+		(yyval.arg) = (yyvsp[(1) - (1)].arg);
+	}
+    break;
+
+  case 53:
+
+/* Line 1806 of yacc.c  */
+#line 463 "parser.y"
+    {
+		struct si2bin_arg_t *arg;
+		struct si2bin_id_t *id;
+
+		int low;
+		int high;
+
+		/* Read arguments */
+		id = (yyvsp[(1) - (6)].id);
+		low = (yyvsp[(3) - (6)].num);
+		high = (yyvsp[(5) - (6)].num);
+		
+		/* Create argument */
+		arg = si2bin_arg_create(); 
+		
+		/* Initialize */
+		if (!strcmp(id->name, "s"))
+		{
+			arg->type = si2bin_arg_scalar_register_series;
+			arg->value.scalar_register_series.low = low;
+			arg->value.scalar_register_series.high = high;
+		}
+		else if (!strcmp(id->name, "v"))
+		{
+			arg->type = si2bin_arg_vector_register_series;
+			arg->value.vector_register_series.low = low;
+			arg->value.vector_register_series.high = high;
+		}
+		else
+		{
+			si2bin_yyerror_fmt("invalid register series: %s", id->name);
+		}
+		
+		/* Return created argument */
+		si2bin_id_free(id);
+		(yyval.arg) = arg;
+	}
+    break;
+
+  case 54:
+
+/* Line 1806 of yacc.c  */
+#line 502 "parser.y"
+    {
+		struct si2bin_arg_t *arg = (yyvsp[(3) - (4)].arg);
+
+		/* Activate absolute value flag */
+		arg->abs = 1;
+
+		/* Check valid application of 'abs' */
+		switch (arg->type)
+		{
+		case si2bin_arg_scalar_register:
+		case si2bin_arg_scalar_register_series:
+		case si2bin_arg_vector_register:
+		case si2bin_arg_vector_register_series:
+			break;
+
+		default:
+			si2bin_yyerror("abs() function not allowed for argument");
+		}
+
+		/* Return */
+		(yyval.arg) = arg;
+	}
+    break;
+
+  case 55:
+
+/* Line 1806 of yacc.c  */
+#line 526 "parser.y"
+    {
+		struct si2bin_arg_t *arg = (yyvsp[(2) - (2)].arg);
+
+		/* Activate absolute value flag */
+		arg->neg = 1;
+
+		/* Check valid application of 'abs' */
+		switch (arg->type)
+		{
+		case si2bin_arg_scalar_register:
+		case si2bin_arg_scalar_register_series:
+		case si2bin_arg_vector_register:
+		case si2bin_arg_vector_register_series:
+			break;
+
+		default:
+			si2bin_yyerror("abs() function not allowed for argument");
+		}
+
+		/* Return */
+		(yyval.arg) = arg;
+	}
+    break;
+
+  case 56:
+
+/* Line 1806 of yacc.c  */
+#line 550 "parser.y"
+    {
+		struct si2bin_arg_t *arg;
+		struct si2bin_arg_t *soffset;
+		struct si2bin_arg_t *qual;
+
+		struct si2bin_id_t *id_data_format;
+		struct si2bin_id_t *id_num_format;
+
+		/* Read arguments */
+		soffset = (yyvsp[(1) - (9)].arg);
+		qual = (yyvsp[(2) - (9)].arg);
+		id_data_format = (yyvsp[(6) - (9)].id);
+		id_num_format = (yyvsp[(8) - (9)].id);
+
+		/* Create argument */
+		arg = si2bin_arg_create_maddr(soffset, qual,
+			id_data_format->name, id_num_format->name);	
+			
+		/* Return */
+		si2bin_id_free(id_data_format);
+		si2bin_id_free(id_num_format);
+		(yyval.arg) = arg;
+	}
+    break;
+
+  case 57:
+
+/* Line 1806 of yacc.c  */
+#line 575 "parser.y"
+    {
+		struct si2bin_arg_t *arg;
+		struct si2bin_id_t *id;
+		struct si2bin_symbol_t *symbol;
+
+		/* Get symbol or create it */
+		id = (yyvsp[(1) - (1)].id);
+		symbol = hash_table_get(si2bin_symbol_table, id->name);
+		if (!symbol)
+		{
+			symbol = si2bin_symbol_create(id->name);
+			hash_table_insert(si2bin_symbol_table, id->name, symbol);
+		}
+		
+		/* Create argument */
+		arg = si2bin_arg_create_label(symbol);
+
+		/* Return */
+		si2bin_id_free(id);
+		(yyval.arg) = arg;
+	}
+    break;
+
+  case 58:
+
+/* Line 1806 of yacc.c  */
+#line 598 "parser.y"
+    {
+		/* The return value is given by 'waitcnt_arg's definition */
+	}
+    break;
+
+  case 59:
+
+/* Line 1806 of yacc.c  */
+#line 606 "parser.y"
+    {
+		(yyval.arg) = si2bin_arg_create_maddr_qual();
+	}
+    break;
+
+  case 60:
+
+/* Line 1806 of yacc.c  */
+#line 611 "parser.y"
+    {
+		struct si2bin_arg_t *qual = (yyvsp[(1) - (2)].arg);
+
+		assert(qual->type == si2bin_arg_maddr_qual);
+		if (qual->value.maddr_qual.offen)
+			si2bin_yyerror("redundant qualifier 'offen'");
+		qual->value.maddr_qual.offen = 1;
+		(yyval.arg) = qual;
+	}
+    break;
+
+  case 61:
+
+/* Line 1806 of yacc.c  */
+#line 622 "parser.y"
+    {
+		struct si2bin_arg_t *qual = (yyvsp[(1) - (2)].arg);
+
+		assert(qual->type == si2bin_arg_maddr_qual);
+		if (qual->value.maddr_qual.idxen)
+			si2bin_yyerror("redundant qualifier 'idxen'");
+		qual->value.maddr_qual.idxen = 1;
+		(yyval.arg) = qual;
+	}
+    break;
+
+  case 62:
+
+/* Line 1806 of yacc.c  */
+#line 633 "parser.y"
+    {
+		struct si2bin_arg_t *qual = (yyvsp[(1) - (4)].arg);
+		int offset = (yyvsp[(4) - (4)].num);
+
+		assert(qual->type == si2bin_arg_maddr_qual);
+		qual->value.maddr_qual.offset = offset;
+		/* FIXME - check range of 'offset' */
+		(yyval.arg) = qual;
+	}
+    break;
+
+  case 64:
+
+/* Line 1806 of yacc.c  */
+#line 648 "parser.y"
+    {
+		if ((yyvsp[(3) - (3)].arg)->value.wait_cnt.vmcnt_active && (yyvsp[(1) - (3)].arg)->value.wait_cnt.vmcnt_active)
+			si2bin_yyerror("duplicate 'vmcnt' token");
+		(yyvsp[(3) - (3)].arg)->value.wait_cnt.vmcnt_active += (yyvsp[(1) - (3)].arg)->value.wait_cnt.vmcnt_active;
+		(yyvsp[(3) - (3)].arg)->value.wait_cnt.vmcnt_value += (yyvsp[(1) - (3)].arg)->value.wait_cnt.vmcnt_value;		
+		
+		if ((yyvsp[(3) - (3)].arg)->value.wait_cnt.expcnt_active && (yyvsp[(1) - (3)].arg)->value.wait_cnt.expcnt_active)
+			si2bin_yyerror("duplicate 'expcnt' token");
+		(yyvsp[(3) - (3)].arg)->value.wait_cnt.expcnt_active += (yyvsp[(1) - (3)].arg)->value.wait_cnt.expcnt_active;
+		(yyvsp[(3) - (3)].arg)->value.wait_cnt.expcnt_value += (yyvsp[(1) - (3)].arg)->value.wait_cnt.expcnt_value;	
+		
+		if ((yyvsp[(3) - (3)].arg)->value.wait_cnt.lgkmcnt_active && (yyvsp[(1) - (3)].arg)->value.wait_cnt.lgkmcnt_active)
+			si2bin_yyerror("duplicate 'lgkmcnt' token");
+		(yyvsp[(3) - (3)].arg)->value.wait_cnt.lgkmcnt_active += (yyvsp[(1) - (3)].arg)->value.wait_cnt.lgkmcnt_active;
+		(yyvsp[(3) - (3)].arg)->value.wait_cnt.lgkmcnt_value += (yyvsp[(1) - (3)].arg)->value.wait_cnt.lgkmcnt_value;	
+		
+		si2bin_arg_free((yyvsp[(1) - (3)].arg));
+		(yyval.arg) = (yyvsp[(3) - (3)].arg);
+	}
+    break;
+
+  case 65:
+
+/* Line 1806 of yacc.c  */
+#line 672 "parser.y"
+    {
+		struct si2bin_arg_t *arg;
+		struct si2bin_id_t *id;
+
+		/* Read arguments */
+		id = (yyvsp[(1) - (4)].id);
+		
+		/* Create argument */
+		arg = si2bin_arg_create(); 
+		
+		/* Initialize */
+		arg->type = si2bin_arg_waitcnt;
+		
+		if (!strcmp(id->name, "vmcnt"))
+		{
+			arg->value.wait_cnt.vmcnt_active = 1;
+			arg->value.wait_cnt.vmcnt_value = (yyvsp[(3) - (4)].num);
+		}
+		else if (!strcmp(id->name, "expcnt"))
+		{
+			arg->value.wait_cnt.expcnt_active = 1;
+			arg->value.wait_cnt.expcnt_value = (yyvsp[(3) - (4)].num);
+		}
+		else if (!strcmp(id->name, "lgkmcnt"))
+		{
+			arg->value.wait_cnt.lgkmcnt_active = 1;
+			arg->value.wait_cnt.lgkmcnt_value = (yyvsp[(3) - (4)].num);
+		}
+		
+		/* Return */
+		si2bin_id_free(id);
+		(yyval.arg) = arg;
+	}
+    break;
+
+
+
+/* Line 1806 of yacc.c  */
+#line 2164 "parser.c"
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 2067 of yacc.c  */
+#line 707 "parser.y"
+
+
--- /dev/null
+++ multi2sim-4.1+svn20130603/tools/clcc/si2bin/parser.h
@@ -0,0 +1,128 @@
+/* A Bison parser, made by GNU Bison 2.5.  */
+
+/* Bison interface for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     TOK_SCALAR_REGISTER = 258,
+     TOK_VECTOR_REGISTER = 259,
+     TOK_SPECIAL_REGISTER = 260,
+     TOK_DECIMAL = 261,
+     TOK_HEX = 262,
+     TOK_FLOAT = 263,
+     TOK_ID = 264,
+     TOK_COMMA = 265,
+     TOK_COLON = 266,
+     TOK_FORMAT = 267,
+     TOK_OFFEN = 268,
+     TOK_IDXEN = 269,
+     TOK_OFFSET = 270,
+     TOK_OBRA = 271,
+     TOK_CBRA = 272,
+     TOK_OPAR = 273,
+     TOK_CPAR = 274,
+     TOK_NEW_LINE = 275,
+     TOK_AMP = 276,
+     TOK_ABS = 277,
+     TOK_NEG = 278,
+     TOK_STAR = 279,
+     TOK_GLOBAL = 280,
+     TOK_MEM = 281,
+     TOK_ARGS = 282,
+     TOK_DATA = 283,
+     TOK_TEXT = 284
+   };
+#endif
+/* Tokens.  */
+#define TOK_SCALAR_REGISTER 258
+#define TOK_VECTOR_REGISTER 259
+#define TOK_SPECIAL_REGISTER 260
+#define TOK_DECIMAL 261
+#define TOK_HEX 262
+#define TOK_FLOAT 263
+#define TOK_ID 264
+#define TOK_COMMA 265
+#define TOK_COLON 266
+#define TOK_FORMAT 267
+#define TOK_OFFEN 268
+#define TOK_IDXEN 269
+#define TOK_OFFSET 270
+#define TOK_OBRA 271
+#define TOK_CBRA 272
+#define TOK_OPAR 273
+#define TOK_CPAR 274
+#define TOK_NEW_LINE 275
+#define TOK_AMP 276
+#define TOK_ABS 277
+#define TOK_NEG 278
+#define TOK_STAR 279
+#define TOK_GLOBAL 280
+#define TOK_MEM 281
+#define TOK_ARGS 282
+#define TOK_DATA 283
+#define TOK_TEXT 284
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 2068 of yacc.c  */
+#line 60 "parser.y"
+
+	int num;
+	float num_float;
+	struct si2bin_id_t *id;
+	struct si2bin_inst_t *inst;
+	struct si_label_t *label;
+	struct list_t *list;
+	struct si2bin_arg_t *arg;
+
+
+
+/* Line 2068 of yacc.c  */
+#line 120 "parser.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE si2bin_yylval;
+
+
--- /dev/null
+++ multi2sim-4.1+svn20130603/tools/clcc/si2bin/lex.c
@@ -0,0 +1,2083 @@
+#line 2 "lex.c"
+
+#line 4 "lex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer si2bin_yy_create_buffer
+#define yy_delete_buffer si2bin_yy_delete_buffer
+#define yy_flex_debug si2bin_yy_flex_debug
+#define yy_init_buffer si2bin_yy_init_buffer
+#define yy_flush_buffer si2bin_yy_flush_buffer
+#define yy_load_buffer_state si2bin_yy_load_buffer_state
+#define yy_switch_to_buffer si2bin_yy_switch_to_buffer
+#define yyin si2bin_yyin
+#define yyleng si2bin_yyleng
+#define yylex si2bin_yylex
+#define yylineno si2bin_yylineno
+#define yyout si2bin_yyout
+#define yyrestart si2bin_yyrestart
+#define yytext si2bin_yytext
+#define yywrap si2bin_yywrap
+#define yyalloc si2bin_yyalloc
+#define yyrealloc si2bin_yyrealloc
+#define yyfree si2bin_yyfree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE si2bin_yyrestart(si2bin_yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int si2bin_yyleng;
+
+extern FILE *si2bin_yyin, *si2bin_yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
+     *       access to the local variable yy_act. Since yyless() is a macro, it would break
+     *       existing scanners that call yyless() from OUTSIDE si2bin_yylex. 
+     *       One obvious solution it to make yy_act a global. I tried that, and saw
+     *       a 5% performance hit in a non-si2bin_yylineno scanner, because yy_act is
+     *       normally declared as a register variable-- so it is not worth it.
+     */
+    #define  YY_LESS_LINENO(n) \
+            do { \
+                int yyl;\
+                for ( yyl = n; yyl < si2bin_yyleng; ++yyl )\
+                    if ( si2bin_yytext[yyl] == '\n' )\
+                        --si2bin_yylineno;\
+            }while(0)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up si2bin_yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up si2bin_yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via si2bin_yyrestart()), so that the user can continue scanning by
+	 * just pointing si2bin_yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when si2bin_yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int si2bin_yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow si2bin_yywrap()'s to do buffer switches
+ * instead of setting up a fresh si2bin_yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void si2bin_yyrestart (FILE *input_file  );
+void si2bin_yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE si2bin_yy_create_buffer (FILE *file,int size  );
+void si2bin_yy_delete_buffer (YY_BUFFER_STATE b  );
+void si2bin_yy_flush_buffer (YY_BUFFER_STATE b  );
+void si2bin_yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void si2bin_yypop_buffer_state (void );
+
+static void si2bin_yyensure_buffer_stack (void );
+static void si2bin_yy_load_buffer_state (void );
+static void si2bin_yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER si2bin_yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE si2bin_yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE si2bin_yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE si2bin_yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *si2bin_yyalloc (yy_size_t  );
+void *si2bin_yyrealloc (void *,yy_size_t  );
+void si2bin_yyfree (void *  );
+
+#define yy_new_buffer si2bin_yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        si2bin_yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            si2bin_yy_create_buffer(si2bin_yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        si2bin_yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            si2bin_yy_create_buffer(si2bin_yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define si2bin_yywrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *si2bin_yyin = (FILE *) 0, *si2bin_yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int si2bin_yylineno;
+
+int si2bin_yylineno = 1;
+
+extern char *si2bin_yytext;
+#define yytext_ptr si2bin_yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up si2bin_yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	si2bin_yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[88] =
+    {   0,
+       10,   10,   34,   32,   31,   10,   30,    9,    4,    5,
+       11,   32,    1,    3,   32,   32,   28,   28,    7,   25,
+        6,    8,   25,   25,   25,   25,   25,   25,   25,   10,
+       30,   28,    0,    0,    0,    0,    0,   29,    0,    0,
+       25,   25,   25,   25,   25,   25,   12,   25,   13,   25,
+        0,    0,    0,    0,    0,   29,   27,   26,    2,   25,
+       25,   25,   25,   14,    0,    0,    0,   21,    0,   25,
+       25,   25,   25,   22,   23,    0,   24,   25,   17,   16,
+       25,    0,   20,   15,   18,   19,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    4,    1,    1,    5,    1,    6,
+        7,    8,    9,   10,   11,   12,   13,   14,   15,   15,
+       15,   15,   15,   15,   15,   15,   15,   16,    1,    1,
+        1,    1,    1,    1,   17,   17,   17,   17,   17,   17,
+       17,   17,   17,   17,   17,   17,   17,   17,   17,   17,
+       17,   17,   17,   17,   17,   17,   17,   17,   17,   17,
+       18,    1,   19,    1,   17,    1,   20,   21,   22,   23,
+
+       24,   25,   26,   27,   28,   27,   27,   29,   30,   31,
+       32,   27,   27,   33,   34,   35,   27,   36,   27,   37,
+       27,   27,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[38] =
+    {   0,
+        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    3,    3,    1,    4,    1,    1,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3
+    } ;
+
+static yyconst flex_int16_t yy_base[92] =
+    {   0,
+        0,    0,  123,  124,  124,  119,    0,  124,  124,  124,
+      124,   24,  124,   26,   22,  108,   32,   39,  124,    0,
+      124,  124,   99,   82,   86,   94,   91,   41,   44,  112,
+        0,   50,   81,   93,   83,   87,   86,    0,   35,    0,
+        0,   75,   84,   74,   69,   80,   46,   82,   53,   81,
+       76,   66,   68,   69,   61,    0,   56,    0,    0,   75,
+       66,   71,   48,    0,   60,   71,   64,  124,   46,   60,
+       48,   47,   53,  124,  124,   54,  124,   41,    0,    0,
+       40,   44,  124,    0,    0,  124,  124,   83,   85,   89,
+       40
+
+    } ;
+
+static yyconst flex_int16_t yy_def[92] =
+    {   0,
+       87,    1,   87,   87,   87,   87,   88,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   89,
+       87,   87,   89,   89,   89,   89,   89,   89,   89,   87,
+       88,   87,   87,   87,   87,   87,   87,   90,   87,   91,
+       89,   89,   89,   89,   89,   89,   89,   89,   89,   89,
+       87,   87,   87,   87,   87,   90,   87,   91,   89,   89,
+       89,   89,   89,   89,   87,   87,   87,   87,   87,   89,
+       89,   89,   89,   87,   87,   87,   87,   89,   89,   89,
+       89,   87,   87,   89,   89,   87,    0,   87,   87,   87,
+       87
+
+    } ;
+
+static yyconst flex_int16_t yy_nxt[162] =
+    {   0,
+        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
+       14,   15,   16,   17,   18,   19,   20,   21,   22,   23,
+       20,   20,   20,   24,   25,   20,   20,   26,   20,   20,
+       20,   27,   20,   28,   20,   29,   20,   32,   32,   32,
+       32,   33,   58,   39,   34,   32,   32,   35,   57,   57,
+       39,   36,   32,   32,   47,   47,   37,   49,   49,   47,
+       47,   39,   48,   32,   32,   50,   49,   49,   40,   57,
+       57,   72,   86,   82,   85,   84,   81,   80,   79,   78,
+       77,   73,   83,   31,   76,   31,   31,   41,   41,   56,
+       75,   56,   56,   74,   71,   70,   64,   69,   68,   67,
+
+       66,   65,   64,   64,   63,   62,   61,   60,   59,   55,
+       54,   53,   52,   51,   30,   46,   45,   44,   43,   42,
+       38,   30,   87,    3,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87
+    } ;
+
+static yyconst flex_int16_t yy_chk[162] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,   12,   12,   14,
+       14,   15,   91,   17,   15,   17,   17,   15,   39,   39,
+       18,   15,   18,   18,   28,   28,   15,   29,   29,   47,
+       47,   32,   28,   32,   32,   29,   49,   49,   17,   57,
+       57,   63,   82,   76,   81,   78,   73,   72,   71,   70,
+       69,   63,   76,   88,   67,   88,   88,   89,   89,   90,
+       66,   90,   90,   65,   62,   61,   60,   55,   54,   53,
+
+       52,   51,   50,   48,   46,   45,   44,   43,   42,   37,
+       36,   35,   34,   33,   30,   27,   26,   25,   24,   23,
+       16,    6,    3,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,   87,   87,   87,   87,   87,   87,   87,
+       87
+    } ;
+
+/* Table of booleans, true if rule could match eol. */
+static yyconst flex_int32_t yy_rule_can_match_eol[34] =
+    {   0,
+0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     };
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int si2bin_yy_flex_debug;
+int si2bin_yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *si2bin_yytext;
+#line 1 "lex.l"
+/*
+ *  Multi2Sim
+ *  Copyright (C) 2012  Rafael Ubal (ubal@ece.neu.edu)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#line 21 "lex.l"
+
+#include "id.h"
+#include "si2bin.h"
+#include "parser.h"
+
+extern long offset;
+#define YY_NO_INPUT 1
+#line 591 "lex.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int si2bin_yylex_destroy (void );
+
+int si2bin_yyget_debug (void );
+
+void si2bin_yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE si2bin_yyget_extra (void );
+
+void si2bin_yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *si2bin_yyget_in (void );
+
+void si2bin_yyset_in  (FILE * in_str  );
+
+FILE *si2bin_yyget_out (void );
+
+void si2bin_yyset_out  (FILE * out_str  );
+
+int si2bin_yyget_leng (void );
+
+char *si2bin_yyget_text (void );
+
+int si2bin_yyget_lineno (void );
+
+void si2bin_yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int si2bin_yywrap (void );
+#else
+extern int si2bin_yywrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( si2bin_yytext, si2bin_yyleng, 1, si2bin_yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( si2bin_yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( si2bin_yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, si2bin_yyin))==0 && ferror(si2bin_yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(si2bin_yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int si2bin_yylex (void);
+
+#define YY_DECL int si2bin_yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after si2bin_yytext and si2bin_yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 35 "lex.l"
+
+
+
+#line 780 "lex.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! si2bin_yyin )
+			si2bin_yyin = stdin;
+
+		if ( ! si2bin_yyout )
+			si2bin_yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			si2bin_yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				si2bin_yy_create_buffer(si2bin_yyin,YY_BUF_SIZE );
+		}
+
+		si2bin_yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of si2bin_yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 88 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 124 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
+			{
+			int yyl;
+			for ( yyl = 0; yyl < si2bin_yyleng; ++yyl )
+				if ( si2bin_yytext[yyl] == '\n' )
+					   
+    si2bin_yylineno++;
+;
+			}
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 38 "lex.l"
+{ 
+	return TOK_COMMA;
+}
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 42 "lex.l"
+{
+	return TOK_ABS;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 46 "lex.l"
+{
+	return TOK_NEG;
+}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 50 "lex.l"
+{ 
+	return TOK_OPAR;
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 54 "lex.l"
+{ 
+	return TOK_CPAR;
+}
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 58 "lex.l"
+{ 
+	return TOK_OBRA;
+}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 62 "lex.l"
+{ 
+	return TOK_COLON;
+}
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 66 "lex.l"
+{   
+	return TOK_CBRA;
+}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 70 "lex.l"
+{
+	return TOK_AMP;
+}
+	YY_BREAK
+case 10:
+/* rule 10 can match eol */
+YY_RULE_SETUP
+#line 74 "lex.l"
+{
+	return TOK_NEW_LINE;
+}
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 78 "lex.l"
+{
+	return TOK_STAR;
+}
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 82 "lex.l"
+{
+	si2bin_yylval.id = si2bin_id_create(si2bin_yytext);
+	return TOK_SCALAR_REGISTER;
+}
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 87 "lex.l"
+{
+	si2bin_yylval.id = si2bin_id_create(si2bin_yytext);
+	return TOK_VECTOR_REGISTER;
+}
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 92 "lex.l"
+{
+	si2bin_yylval.id = si2bin_id_create(si2bin_yytext);
+	return TOK_SPECIAL_REGISTER;
+}
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 97 "lex.l"
+{
+	return TOK_FORMAT;
+}
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 101 "lex.l"
+{
+	return TOK_OFFEN;
+}
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 105 "lex.l"
+{
+	return TOK_IDXEN;
+}
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 109 "lex.l"
+{
+	return TOK_OFFSET;
+}
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 113 "lex.l"
+{
+	return TOK_GLOBAL;
+}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 117 "lex.l"
+{
+	return TOK_GLOBAL;
+}
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 121 "lex.l"
+{
+	return TOK_MEM;
+}
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 125 "lex.l"
+{
+	return TOK_ARGS;
+}
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 129 "lex.l"
+{
+	return TOK_DATA;
+}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 133 "lex.l"
+{
+	return TOK_TEXT;
+}
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 137 "lex.l"
+{   
+	si2bin_yylval.id = si2bin_id_create(si2bin_yytext);
+	return TOK_ID; 
+}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 142 "lex.l"
+{ 
+	si2bin_yylval.id = si2bin_id_create(si2bin_yytext);
+	return TOK_HEX;	
+}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 147 "lex.l"
+{
+	si2bin_yylval.num_float = atof(si2bin_yytext);
+	return TOK_FLOAT;
+}
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 152 "lex.l"
+{
+	si2bin_yylval.num = atoi(si2bin_yytext);
+	return TOK_DECIMAL;
+}
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 157 "lex.l"
+{
+	/* Ignore comments */
+}
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 161 "lex.l"
+{
+	/* Ignore comments */
+}
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 165 "lex.l"
+{
+	/* Ignore tabs and spaces */
+}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 169 "lex.l"
+{
+	/* Lexical error */
+	si2bin_yyerror_fmt("unexpected character: %s\n", si2bin_yytext);
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 174 "lex.l"
+ECHO;
+	YY_BREAK
+#line 1111 "lex.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed si2bin_yyin at a new source and called
+			 * si2bin_yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = si2bin_yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( si2bin_yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * si2bin_yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of si2bin_yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					si2bin_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			si2bin_yyrestart(si2bin_yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) si2bin_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 88 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 88 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 87);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					si2bin_yyrestart(si2bin_yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( si2bin_yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve si2bin_yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	if ( c == '\n' )
+		   
+    si2bin_yylineno++;
+;
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void si2bin_yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        si2bin_yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            si2bin_yy_create_buffer(si2bin_yyin,YY_BUF_SIZE );
+	}
+
+	si2bin_yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	si2bin_yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void si2bin_yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		si2bin_yypop_buffer_state();
+	 *		si2bin_yypush_buffer_state(new_buffer);
+     */
+	si2bin_yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	si2bin_yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (si2bin_yywrap()) processing, but the only time this flag
+	 * is looked at is after si2bin_yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void si2bin_yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	si2bin_yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE si2bin_yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) si2bin_yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in si2bin_yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) si2bin_yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in si2bin_yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	si2bin_yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with si2bin_yy_create_buffer()
+ * 
+ */
+    void si2bin_yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		si2bin_yyfree((void *) b->yy_ch_buf  );
+
+	si2bin_yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a si2bin_yyrestart() or at EOF.
+ */
+    static void si2bin_yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	si2bin_yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then si2bin_yy_init_buffer was _probably_
+     * called from si2bin_yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void si2bin_yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		si2bin_yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void si2bin_yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	si2bin_yyensure_buffer_stack();
+
+	/* This block is copied from si2bin_yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from si2bin_yy_switch_to_buffer. */
+	si2bin_yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void si2bin_yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	si2bin_yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		si2bin_yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void si2bin_yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)si2bin_yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in si2bin_yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)si2bin_yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in si2bin_yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE si2bin_yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) si2bin_yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in si2bin_yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	si2bin_yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to si2bin_yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       si2bin_yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE si2bin_yy_scan_string (yyconst char * yystr )
+{
+    
+	return si2bin_yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to si2bin_yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE si2bin_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) si2bin_yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in si2bin_yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = si2bin_yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in si2bin_yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up si2bin_yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		si2bin_yytext[si2bin_yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = si2bin_yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		si2bin_yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int si2bin_yyget_lineno  (void)
+{
+        
+    return si2bin_yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *si2bin_yyget_in  (void)
+{
+        return si2bin_yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *si2bin_yyget_out  (void)
+{
+        return si2bin_yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int si2bin_yyget_leng  (void)
+{
+        return si2bin_yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *si2bin_yyget_text  (void)
+{
+        return si2bin_yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void si2bin_yyset_lineno (int  line_number )
+{
+    
+    si2bin_yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see si2bin_yy_switch_to_buffer
+ */
+void si2bin_yyset_in (FILE *  in_str )
+{
+        si2bin_yyin = in_str ;
+}
+
+void si2bin_yyset_out (FILE *  out_str )
+{
+        si2bin_yyout = out_str ;
+}
+
+int si2bin_yyget_debug  (void)
+{
+        return si2bin_yy_flex_debug;
+}
+
+void si2bin_yyset_debug (int  bdebug )
+{
+        si2bin_yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from si2bin_yylex_destroy(), so don't allocate here.
+     */
+
+    /* We do not touch si2bin_yylineno unless the option is enabled. */
+    si2bin_yylineno =  1;
+    
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    si2bin_yyin = stdin;
+    si2bin_yyout = stdout;
+#else
+    si2bin_yyin = (FILE *) 0;
+    si2bin_yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * si2bin_yylex_init()
+     */
+    return 0;
+}
+
+/* si2bin_yylex_destroy is for both reentrant and non-reentrant scanners. */
+int si2bin_yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		si2bin_yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		si2bin_yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	si2bin_yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * si2bin_yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *si2bin_yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *si2bin_yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void si2bin_yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see si2bin_yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 174 "lex.l"
+
+
+
+
--- /dev/null
+++ multi2sim-4.1+svn20130603/tools/clcc/cl2llvm/parser.c
@@ -0,0 +1,5091 @@
+/* A Bison parser, made by GNU Bison 2.5.  */
+
+/* Bison implementation for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.5"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse         cl2llvm_yyparse
+#define yylex           cl2llvm_yylex
+#define yyerror         cl2llvm_yyerror
+#define yylval          cl2llvm_yylval
+#define yychar          cl2llvm_yychar
+#define yydebug         cl2llvm_yydebug
+#define yynerrs         cl2llvm_yynerrs
+
+
+/* Copy the first part of user declarations.  */
+
+/* Line 268 of yacc.c  */
+#line 1 "parser.y"
+
+
+#define YYDEBUG 1
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <lib/util/debug.h>
+#include <lib/util/hash-table.h>
+#include <lib/util/list.h>
+#include <llvm-c/Core.h>
+#include <llvm-c/Analysis.h>
+#include <llvm-c/ExecutionEngine.h>
+#include <llvm-c/Target.h>
+#include <llvm-c/Transforms/Scalar.h>
+#include <llvm-c/BitWriter.h>
+
+#include "arg.h"
+#include "declarator-list.h"
+#include "function.h"
+#include "val.h"
+#include "type.h"
+#include "init.h"
+#include "symbol.h"
+#include "parser.h"
+#include "cl2llvm.h"
+
+
+extern LLVMBuilderRef cl2llvm_builder;
+extern LLVMModuleRef cl2llvm_module;
+extern LLVMValueRef cl2llvm_function;
+extern LLVMBasicBlockRef cl2llvm_basic_block;
+
+extern int temp_var_count;
+extern char temp_var_name[50];
+
+int block_count;
+char block_name[50];
+
+int  func_count;
+char func_name[50];
+
+struct hash_table_t *cl2llvm_symbol_table;
+
+struct cl2llvm_function_t *current_function;
+
+
+/* Line 268 of yacc.c  */
+#line 129 "parser.c"
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     TOK_ID = 258,
+     TOK_CONST_INT = 259,
+     TOK_CONST_INT_U = 260,
+     TOK_CONST_INT_L = 261,
+     TOK_CONST_INT_UL = 262,
+     TOK_CONST_INT_LL = 263,
+     TOK_CONST_INT_ULL = 264,
+     TOK_CONST_DEC = 265,
+     TOK_CONST_DEC_H = 266,
+     TOK_CONST_DEC_F = 267,
+     TOK_CONST_DEC_L = 268,
+     TOK_CONST_VAL = 269,
+     TOK_STRING = 270,
+     TOK_COMMA = 271,
+     TOK_SEMICOLON = 272,
+     TOK_ELLIPSIS = 273,
+     TOK_SHIFT_LEFT_EQUAL = 274,
+     TOK_SHIFT_RIGHT_EQUAL = 275,
+     TOK_EXCLUSIVE_EQUAL = 276,
+     TOK_OR_EQUAL = 277,
+     TOK_AND_EQUAL = 278,
+     TOK_MOD_EQUAL = 279,
+     TOK_DIV_EQUAL = 280,
+     TOK_MULT_EQUAL = 281,
+     TOK_MINUS_EQUAL = 282,
+     TOK_ADD_EQUAL = 283,
+     TOK_EQUAL = 284,
+     TOK_COLON = 285,
+     TOK_CONDITIONAL = 286,
+     TOK_LOGICAL_OR = 287,
+     TOK_LOGICAL_AND = 288,
+     TOK_BITWISE_OR = 289,
+     TOK_BITWISE_EXCLUSIVE = 290,
+     TOK_BITWISE_AND = 291,
+     TOK_INEQUALITY = 292,
+     TOK_EQUALITY = 293,
+     TOK_LESS_EQUAL = 294,
+     TOK_GREATER_EQUAL = 295,
+     TOK_LESS = 296,
+     TOK_GREATER = 297,
+     TOK_SHIFT_LEFT = 298,
+     TOK_SHIFT_RIGHT = 299,
+     TOK_MINUS = 300,
+     TOK_PLUS = 301,
+     TOK_MOD = 302,
+     TOK_DIV = 303,
+     TOK_MULT = 304,
+     TOK_BITWISE_NOT = 305,
+     TOK_LOGICAL_NEGATE = 306,
+     TOK_PREFIX = 307,
+     TOK_CURLY_BRACE_CLOSE = 308,
+     TOK_CURLY_BRACE_OPEN = 309,
+     TOK_STRUCT_DEREF = 310,
+     TOK_STRUCT_REF = 311,
+     TOK_POSTFIX = 312,
+     TOK_BRACKET_CLOSE = 313,
+     TOK_BRACKET_OPEN = 314,
+     TOK_PAR_CLOSE = 315,
+     TOK_PAR_OPEN = 316,
+     TOK_DECREMENT = 317,
+     TOK_INCREMENT = 318,
+     TOK_AUTO = 319,
+     TOK_BOOL = 320,
+     TOK_BREAK = 321,
+     TOK_CASE = 322,
+     TOK_CHAR = 323,
+     TOK_CHARN = 324,
+     TOK_CONSTANT = 325,
+     TOK_CONST = 326,
+     TOK_CONTINUE = 327,
+     TOK_DEFAULT = 328,
+     TOK_DO = 329,
+     TOK_DOUBLE = 330,
+     TOK_DOUBLE_LONG = 331,
+     TOK_DOUBLEN = 332,
+     TOK_ENUM = 333,
+     TOK_EVENT_T = 334,
+     TOK_EXTERN = 335,
+     TOK_FLOAT = 336,
+     TOK_FLOATN = 337,
+     TOK_FOR = 338,
+     TOK_GLOBAL = 339,
+     TOK_GOTO = 340,
+     TOK_HALF = 341,
+     TOK_IF = 342,
+     TOK_ELSE = 343,
+     TOK_IMAGE2D_T = 344,
+     TOK_IMAGE3D_T = 345,
+     TOK_IMAGE2D_ARRAY_T = 346,
+     TOK_IMAGE1D_T = 347,
+     TOK_IMAGE1D_BUFFER_T = 348,
+     TOK_IMAGE1D_ARRAY_T = 349,
+     TOK_INLINE = 350,
+     TOK_INT = 351,
+     TOK_INT_LONG = 352,
+     TOK_LONG_LONG = 353,
+     TOK_INTN = 354,
+     TOK_INTPTR_T = 355,
+     TOK_KERNEL = 356,
+     TOK_LOCAL = 357,
+     TOK_LONG = 358,
+     TOK_LONGN = 359,
+     TOK_PRIVATE = 360,
+     TOK_PTRDIFF_T = 361,
+     TOK_READ_ONLY = 362,
+     TOK_READ_WRITE = 363,
+     TOK_REGISTER = 364,
+     TOK_RETURN = 365,
+     TOK_SAMPLER_T = 366,
+     TOK_SHORT = 367,
+     TOK_SHORTN = 368,
+     TOK_SIGNED = 369,
+     TOK_SIZEOF = 370,
+     TOK_SIZE_T = 371,
+     TOK_STATIC = 372,
+     TOK_STRUCT = 373,
+     TOK_SWITCH = 374,
+     TOK_TYPEDEF = 375,
+     TOK_TYPENAME = 376,
+     TOK_UCHARN = 377,
+     TOK_UCHAR = 378,
+     TOK_ULONG = 379,
+     TOK_USHORT = 380,
+     TOK_UINT = 381,
+     TOK_UINT_LONG = 382,
+     TOK_UINT_LONG_LONG = 383,
+     TOK_UINTN = 384,
+     TOK_ULONGN = 385,
+     TOK_UINTPTR_T = 386,
+     TOK_UNION = 387,
+     TOK_UNSIGNED = 388,
+     TOK_USHORTN = 389,
+     TOK_VOID = 390,
+     TOK_VOLATILE = 391,
+     TOK_WHILE = 392,
+     TOK_WRITE_ONLY = 393
+   };
+#endif
+/* Tokens.  */
+#define TOK_ID 258
+#define TOK_CONST_INT 259
+#define TOK_CONST_INT_U 260
+#define TOK_CONST_INT_L 261
+#define TOK_CONST_INT_UL 262
+#define TOK_CONST_INT_LL 263
+#define TOK_CONST_INT_ULL 264
+#define TOK_CONST_DEC 265
+#define TOK_CONST_DEC_H 266
+#define TOK_CONST_DEC_F 267
+#define TOK_CONST_DEC_L 268
+#define TOK_CONST_VAL 269
+#define TOK_STRING 270
+#define TOK_COMMA 271
+#define TOK_SEMICOLON 272
+#define TOK_ELLIPSIS 273
+#define TOK_SHIFT_LEFT_EQUAL 274
+#define TOK_SHIFT_RIGHT_EQUAL 275
+#define TOK_EXCLUSIVE_EQUAL 276
+#define TOK_OR_EQUAL 277
+#define TOK_AND_EQUAL 278
+#define TOK_MOD_EQUAL 279
+#define TOK_DIV_EQUAL 280
+#define TOK_MULT_EQUAL 281
+#define TOK_MINUS_EQUAL 282
+#define TOK_ADD_EQUAL 283
+#define TOK_EQUAL 284
+#define TOK_COLON 285
+#define TOK_CONDITIONAL 286
+#define TOK_LOGICAL_OR 287
+#define TOK_LOGICAL_AND 288
+#define TOK_BITWISE_OR 289
+#define TOK_BITWISE_EXCLUSIVE 290
+#define TOK_BITWISE_AND 291
+#define TOK_INEQUALITY 292
+#define TOK_EQUALITY 293
+#define TOK_LESS_EQUAL 294
+#define TOK_GREATER_EQUAL 295
+#define TOK_LESS 296
+#define TOK_GREATER 297
+#define TOK_SHIFT_LEFT 298
+#define TOK_SHIFT_RIGHT 299
+#define TOK_MINUS 300
+#define TOK_PLUS 301
+#define TOK_MOD 302
+#define TOK_DIV 303
+#define TOK_MULT 304
+#define TOK_BITWISE_NOT 305
+#define TOK_LOGICAL_NEGATE 306
+#define TOK_PREFIX 307
+#define TOK_CURLY_BRACE_CLOSE 308
+#define TOK_CURLY_BRACE_OPEN 309
+#define TOK_STRUCT_DEREF 310
+#define TOK_STRUCT_REF 311
+#define TOK_POSTFIX 312
+#define TOK_BRACKET_CLOSE 313
+#define TOK_BRACKET_OPEN 314
+#define TOK_PAR_CLOSE 315
+#define TOK_PAR_OPEN 316
+#define TOK_DECREMENT 317
+#define TOK_INCREMENT 318
+#define TOK_AUTO 319
+#define TOK_BOOL 320
+#define TOK_BREAK 321
+#define TOK_CASE 322
+#define TOK_CHAR 323
+#define TOK_CHARN 324
+#define TOK_CONSTANT 325
+#define TOK_CONST 326
+#define TOK_CONTINUE 327
+#define TOK_DEFAULT 328
+#define TOK_DO 329
+#define TOK_DOUBLE 330
+#define TOK_DOUBLE_LONG 331
+#define TOK_DOUBLEN 332
+#define TOK_ENUM 333
+#define TOK_EVENT_T 334
+#define TOK_EXTERN 335
+#define TOK_FLOAT 336
+#define TOK_FLOATN 337
+#define TOK_FOR 338
+#define TOK_GLOBAL 339
+#define TOK_GOTO 340
+#define TOK_HALF 341
+#define TOK_IF 342
+#define TOK_ELSE 343
+#define TOK_IMAGE2D_T 344
+#define TOK_IMAGE3D_T 345
+#define TOK_IMAGE2D_ARRAY_T 346
+#define TOK_IMAGE1D_T 347
+#define TOK_IMAGE1D_BUFFER_T 348
+#define TOK_IMAGE1D_ARRAY_T 349
+#define TOK_INLINE 350
+#define TOK_INT 351
+#define TOK_INT_LONG 352
+#define TOK_LONG_LONG 353
+#define TOK_INTN 354
+#define TOK_INTPTR_T 355
+#define TOK_KERNEL 356
+#define TOK_LOCAL 357
+#define TOK_LONG 358
+#define TOK_LONGN 359
+#define TOK_PRIVATE 360
+#define TOK_PTRDIFF_T 361
+#define TOK_READ_ONLY 362
+#define TOK_READ_WRITE 363
+#define TOK_REGISTER 364
+#define TOK_RETURN 365
+#define TOK_SAMPLER_T 366
+#define TOK_SHORT 367
+#define TOK_SHORTN 368
+#define TOK_SIGNED 369
+#define TOK_SIZEOF 370
+#define TOK_SIZE_T 371
+#define TOK_STATIC 372
+#define TOK_STRUCT 373
+#define TOK_SWITCH 374
+#define TOK_TYPEDEF 375
+#define TOK_TYPENAME 376
+#define TOK_UCHARN 377
+#define TOK_UCHAR 378
+#define TOK_ULONG 379
+#define TOK_USHORT 380
+#define TOK_UINT 381
+#define TOK_UINT_LONG 382
+#define TOK_UINT_LONG_LONG 383
+#define TOK_UINTN 384
+#define TOK_ULONGN 385
+#define TOK_UINTPTR_T 386
+#define TOK_UNION 387
+#define TOK_UNSIGNED 388
+#define TOK_USHORTN 389
+#define TOK_VOID 390
+#define TOK_VOLATILE 391
+#define TOK_WHILE 392
+#define TOK_WRITE_ONLY 393
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 293 of yacc.c  */
+#line 50 "parser.y"
+
+	long int const_int_val;
+	unsigned long long const_int_val_ull;
+	double  const_float_val;
+	char * identifier;
+	struct cl2llvm_type_t *llvm_type_ref;
+	struct cl2llvm_val_t *llvm_value_ref;
+	struct list_t * init_list;
+	struct list_t * list_val_t;
+	struct cl2llvm_arg_t *arg_t;
+	struct list_t *arg_list;
+	LLVMBasicBlockRef basic_block_ref;
+	struct cl2llvm_decl_list_t *decl_list;
+
+
+
+/* Line 293 of yacc.c  */
+#line 458 "parser.c"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 343 of yacc.c  */
+#line 470 "parser.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  63
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   1872
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  139
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  53
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  208
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  345
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   393
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
+      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,
+      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,    97,    98,    99,   100,   101,   102,   103,   104,
+     105,   106,   107,   108,   109,   110,   111,   112,   113,   114,
+     115,   116,   117,   118,   119,   120,   121,   122,   123,   124,
+     125,   126,   127,   128,   129,   130,   131,   132,   133,   134,
+     135,   136,   137,   138
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     5,     8,    10,    12,    19,    20,    30,
+      31,    33,    37,    40,    42,    44,    47,    49,    51,    53,
+      55,    57,    59,    61,    63,    65,    67,    69,    71,    73,
+      75,    77,    79,    81,    83,    84,    87,    91,    94,    97,
+      99,   101,   105,   111,   116,   121,   125,   129,   134,   137,
+     139,   141,   143,   145,   147,   149,   151,   155,   158,   161,
+     163,   165,   167,   172,   176,   178,   182,   184,   188,   192,
+     198,   202,   203,   206,   209,   212,   217,   221,   227,   231,
+     233,   237,   240,   244,   250,   252,   254,   257,   260,   264,
+     269,   271,   272,   277,   278,   285,   288,   297,   305,   313,
+     314,   322,   323,   324,   326,   328,   332,   336,   340,   344,
+     348,   352,   356,   360,   364,   368,   372,   376,   380,   384,
+     388,   392,   396,   400,   404,   408,   412,   416,   420,   424,
+     428,   432,   436,   442,   444,   446,   449,   453,   457,   461,
+     464,   467,   470,   473,   476,   479,   484,   489,   492,   495,
+     502,   504,   506,   508,   512,   514,   518,   520,   522,   524,
+     526,   528,   530,   532,   534,   536,   538,   540,   542,   544,
+     547,   549,   552,   554,   556,   558,   560,   562,   564,   566,
+     568,   570,   572,   574,   576,   578,   580,   582,   584,   586,
+     588,   590,   592,   594,   596,   598,   600,   602,   604,   606,
+     608,   610,   612,   614,   616,   618,   620,   622,   624
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int16 yyrhs[] =
+{
+     140,     0,    -1,   141,    -1,   140,   141,    -1,   143,    -1,
+     142,    -1,   147,     3,    61,   145,    60,    17,    -1,    -1,
+     147,     3,    61,   145,    60,    54,   144,   153,    53,    -1,
+      -1,   146,    -1,   145,    16,   146,    -1,   147,     3,    -1,
+     147,    -1,   149,    -1,   147,   149,    -1,    84,    -1,   102,
+      -1,   105,    -1,    70,    -1,   189,    -1,   151,    -1,   101,
+      -1,    95,    -1,   152,    -1,   148,    -1,   150,    -1,    71,
+      -1,   136,    -1,   107,    -1,   138,    -1,   108,    -1,    80,
+      -1,   117,    -1,    -1,   164,   153,    -1,   190,     3,   156,
+      -1,     3,   156,    -1,   190,     3,    -1,     3,    -1,   155,
+      -1,     3,    56,     3,    -1,     3,   156,    56,     3,   156,
+      -1,     3,   156,    56,     3,    -1,     3,    56,     3,   156,
+      -1,   155,    56,     3,    -1,    59,   182,    58,    -1,   156,
+      59,   182,    58,    -1,   181,    17,    -1,   163,    -1,   143,
+      -1,   142,    -1,   175,    -1,   178,    -1,   177,    -1,   171,
+      -1,   110,   182,    17,    -1,    72,    17,    -1,    66,    17,
+      -1,   167,    -1,   165,    -1,   166,    -1,     3,    61,   159,
+      60,    -1,     3,    61,    60,    -1,   182,    -1,   156,    29,
+     182,    -1,   160,    -1,   159,    16,   182,    -1,   159,    16,
+     160,    -1,   159,    16,   156,    29,   182,    -1,    54,   159,
+      53,    -1,    -1,    29,   182,    -1,    29,   160,    -1,     3,
+     161,    -1,   162,    16,     3,   161,    -1,     3,   156,   161,
+      -1,   162,    16,     3,   156,   161,    -1,   147,   162,    17,
+      -1,   157,    -1,    54,   153,    53,    -1,     3,    30,    -1,
+      85,     3,    17,    -1,   119,   182,    54,   168,    53,    -1,
+     169,    -1,   170,    -1,   168,   169,    -1,   168,   170,    -1,
+      73,    30,   153,    -1,    67,   182,    30,   153,    -1,   173,
+      -1,    -1,   173,    88,   172,   164,    -1,    -1,    87,    61,
+     182,    60,   174,   164,    -1,   176,   164,    -1,    83,    61,
+     181,    17,   181,    17,   181,    60,    -1,    83,    61,   163,
+     181,    17,   181,    60,    -1,    74,   164,   137,    61,   182,
+      60,    17,    -1,    -1,   137,   180,    61,   182,    60,   179,
+     164,    -1,    -1,    -1,   182,    -1,   188,    -1,    61,   182,
+      60,    -1,   182,    46,   182,    -1,   182,    45,   182,    -1,
+     182,    49,   182,    -1,   182,    48,   182,    -1,   182,    47,
+     182,    -1,   182,    43,   182,    -1,   182,    44,   182,    -1,
+     182,    38,   182,    -1,   182,    37,   182,    -1,   182,    41,
+     182,    -1,   182,    42,   182,    -1,   182,    39,   182,    -1,
+     182,    40,   182,    -1,   182,    33,   182,    -1,   182,    32,
+     182,    -1,   154,    29,   182,    -1,   154,    28,   182,    -1,
+     154,    27,   182,    -1,   154,    25,   182,    -1,   154,    26,
+     182,    -1,   154,    24,   182,    -1,   154,    23,   182,    -1,
+     154,    22,   182,    -1,   154,    21,   182,    -1,   154,    20,
+     182,    -1,   154,    19,   182,    -1,   182,    31,   182,    30,
+     182,    -1,   183,    -1,   158,    -1,    51,   182,    -1,   182,
+      36,   182,    -1,   182,    34,   182,    -1,   182,    35,   182,
+      -1,   154,    63,    -1,    63,   154,    -1,    62,   154,    -1,
+     154,    62,    -1,    45,   188,    -1,    46,   188,    -1,    61,
+     189,    60,   182,    -1,   115,    61,   189,    60,    -1,    50,
+     182,    -1,    36,   154,    -1,    61,   189,    60,    61,   187,
+      60,    -1,   182,    -1,   156,    -1,   160,    -1,   185,    16,
+     185,    -1,   186,    -1,   185,    16,   187,    -1,     4,    -1,
+       6,    -1,     5,    -1,     7,    -1,     8,    -1,     9,    -1,
+      10,    -1,    11,    -1,    12,    -1,    13,    -1,   154,    -1,
+     184,    -1,   191,    -1,   191,   190,    -1,    49,    -1,   190,
+      49,    -1,   100,    -1,   106,    -1,   131,    -1,   111,    -1,
+      79,    -1,    89,    -1,    90,    -1,    91,    -1,    92,    -1,
+      93,    -1,    94,    -1,   126,    -1,   127,    -1,   128,    -1,
+     123,    -1,   112,    -1,   125,    -1,   129,    -1,   122,    -1,
+     130,    -1,   134,    -1,   113,    -1,    99,    -1,   104,    -1,
+      69,    -1,    82,    -1,    77,    -1,    96,    -1,    97,    -1,
+      98,    -1,    68,    -1,    81,    -1,    65,    -1,    75,    -1,
+      76,    -1,   135,    -1,    86,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   203,   203,   204,   208,   209,   213,   218,   217,   309,
+     316,   323,   332,   338,   349,   353,   362,   363,   364,   365,
+     369,   375,   381,   387,   393,   400,   406,   415,   416,   420,
+     421,   422,   427,   428,   431,   433,   437,   442,   468,   472,
+     486,   493,   494,   495,   496,   497,   502,   511,   521,   525,
+     526,   527,   528,   529,   530,   531,   532,   546,   547,   548,
+     549,   550,   554,   598,   605,   611,   615,   619,   624,   628,
+     635,   640,   643,   647,   654,   665,   675,   688,   703,   765,
+     766,   770,   774,   778,   782,   783,   784,   785,   789,   793,
+     797,   804,   803,   827,   826,   859,   863,   864,   868,   873,
+     872,   902,   912,   918,   921,   923,   928,   978,  1031,  1084,
+    1145,  1196,  1197,  1198,  1252,  1307,  1372,  1436,  1500,  1564,
+    1565,  1566,  1578,  1628,  1678,  1735,  1785,  1833,  1834,  1835,
+    1836,  1837,  1838,  1840,  1845,  1850,  1855,  1856,  1857,  1862,
+    1866,  1870,  1874,  1878,  1882,  1886,  1892,  1896,  1900,  1911,
+    1915,  1916,  1917,  1921,  1925,  1926,  1931,  1937,  1943,  1949,
+    1955,  1961,  1967,  1973,  1979,  1985,  1991,  2009,  2017,  2021,
+    2042,  2047,  2054,  2058,  2062,  2066,  2070,  2074,  2078,  2082,
+    2086,  2090,  2094,  2098,  2104,  2110,  2116,  2122,  2128,  2134,
+    2138,  2142,  2146,  2150,  2154,  2158,  2162,  2166,  2170,  2174,
+    2180,  2186,  2192,  2198,  2204,  2210,  2216,  2222,  2229
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "TOK_ID", "TOK_CONST_INT",
+  "TOK_CONST_INT_U", "TOK_CONST_INT_L", "TOK_CONST_INT_UL",
+  "TOK_CONST_INT_LL", "TOK_CONST_INT_ULL", "TOK_CONST_DEC",
+  "TOK_CONST_DEC_H", "TOK_CONST_DEC_F", "TOK_CONST_DEC_L", "TOK_CONST_VAL",
+  "TOK_STRING", "TOK_COMMA", "TOK_SEMICOLON", "TOK_ELLIPSIS",
+  "TOK_SHIFT_LEFT_EQUAL", "TOK_SHIFT_RIGHT_EQUAL", "TOK_EXCLUSIVE_EQUAL",
+  "TOK_OR_EQUAL", "TOK_AND_EQUAL", "TOK_MOD_EQUAL", "TOK_DIV_EQUAL",
+  "TOK_MULT_EQUAL", "TOK_MINUS_EQUAL", "TOK_ADD_EQUAL", "TOK_EQUAL",
+  "TOK_COLON", "TOK_CONDITIONAL", "TOK_LOGICAL_OR", "TOK_LOGICAL_AND",
+  "TOK_BITWISE_OR", "TOK_BITWISE_EXCLUSIVE", "TOK_BITWISE_AND",
+  "TOK_INEQUALITY", "TOK_EQUALITY", "TOK_LESS_EQUAL", "TOK_GREATER_EQUAL",
+  "TOK_LESS", "TOK_GREATER", "TOK_SHIFT_LEFT", "TOK_SHIFT_RIGHT",
+  "TOK_MINUS", "TOK_PLUS", "TOK_MOD", "TOK_DIV", "TOK_MULT",
+  "TOK_BITWISE_NOT", "TOK_LOGICAL_NEGATE", "TOK_PREFIX",
+  "TOK_CURLY_BRACE_CLOSE", "TOK_CURLY_BRACE_OPEN", "TOK_STRUCT_DEREF",
+  "TOK_STRUCT_REF", "TOK_POSTFIX", "TOK_BRACKET_CLOSE", "TOK_BRACKET_OPEN",
+  "TOK_PAR_CLOSE", "TOK_PAR_OPEN", "TOK_DECREMENT", "TOK_INCREMENT",
+  "TOK_AUTO", "TOK_BOOL", "TOK_BREAK", "TOK_CASE", "TOK_CHAR", "TOK_CHARN",
+  "TOK_CONSTANT", "TOK_CONST", "TOK_CONTINUE", "TOK_DEFAULT", "TOK_DO",
+  "TOK_DOUBLE", "TOK_DOUBLE_LONG", "TOK_DOUBLEN", "TOK_ENUM",
+  "TOK_EVENT_T", "TOK_EXTERN", "TOK_FLOAT", "TOK_FLOATN", "TOK_FOR",
+  "TOK_GLOBAL", "TOK_GOTO", "TOK_HALF", "TOK_IF", "TOK_ELSE",
+  "TOK_IMAGE2D_T", "TOK_IMAGE3D_T", "TOK_IMAGE2D_ARRAY_T", "TOK_IMAGE1D_T",
+  "TOK_IMAGE1D_BUFFER_T", "TOK_IMAGE1D_ARRAY_T", "TOK_INLINE", "TOK_INT",
+  "TOK_INT_LONG", "TOK_LONG_LONG", "TOK_INTN", "TOK_INTPTR_T",
+  "TOK_KERNEL", "TOK_LOCAL", "TOK_LONG", "TOK_LONGN", "TOK_PRIVATE",
+  "TOK_PTRDIFF_T", "TOK_READ_ONLY", "TOK_READ_WRITE", "TOK_REGISTER",
+  "TOK_RETURN", "TOK_SAMPLER_T", "TOK_SHORT", "TOK_SHORTN", "TOK_SIGNED",
+  "TOK_SIZEOF", "TOK_SIZE_T", "TOK_STATIC", "TOK_STRUCT", "TOK_SWITCH",
+  "TOK_TYPEDEF", "TOK_TYPENAME", "TOK_UCHARN", "TOK_UCHAR", "TOK_ULONG",
+  "TOK_USHORT", "TOK_UINT", "TOK_UINT_LONG", "TOK_UINT_LONG_LONG",
+  "TOK_UINTN", "TOK_ULONGN", "TOK_UINTPTR_T", "TOK_UNION", "TOK_UNSIGNED",
+  "TOK_USHORTN", "TOK_VOID", "TOK_VOLATILE", "TOK_WHILE", "TOK_WRITE_ONLY",
+  "$accept", "program", "external_def", "func_decl", "func_def", "$@1",
+  "arg_list", "arg", "declarator_list", "access_qual", "declarator",
+  "type_qual", "addr_qual", "sc_spec", "stmt_list", "lvalue",
+  "struct_deref_list", "array_deref_list", "stmt", "func_call",
+  "param_list", "array_init", "init", "init_list", "declaration",
+  "stmt_or_stmt_list", "label_stmt", "goto_stmt", "switch_stmt",
+  "switch_body", "default_clause", "case_clause", "if_stmt", "@2", "if",
+  "@3", "for_loop", "for_loop_header", "do_while_loop", "while_loop", "@4",
+  "while_loop_block", "maybe_expr", "expr", "unary_expr", "vec_literal",
+  "vec_literal_param_elem", "vec_literal_param_two_elem",
+  "vec_literal_param_list", "primary", "type_spec", "type_ptr_list",
+  "type_name", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
+     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,
+     315,   316,   317,   318,   319,   320,   321,   322,   323,   324,
+     325,   326,   327,   328,   329,   330,   331,   332,   333,   334,
+     335,   336,   337,   338,   339,   340,   341,   342,   343,   344,
+     345,   346,   347,   348,   349,   350,   351,   352,   353,   354,
+     355,   356,   357,   358,   359,   360,   361,   362,   363,   364,
+     365,   366,   367,   368,   369,   370,   371,   372,   373,   374,
+     375,   376,   377,   378,   379,   380,   381,   382,   383,   384,
+     385,   386,   387,   388,   389,   390,   391,   392,   393
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,   139,   140,   140,   141,   141,   142,   144,   143,   145,
+     145,   145,   146,   146,   147,   147,   148,   148,   148,   148,
+     149,   149,   149,   149,   149,   149,   149,   150,   150,   151,
+     151,   151,   152,   152,   153,   153,   154,   154,   154,   154,
+     154,   155,   155,   155,   155,   155,   156,   156,   157,   157,
+     157,   157,   157,   157,   157,   157,   157,   157,   157,   157,
+     157,   157,   158,   158,   159,   159,   159,   159,   159,   159,
+     160,   161,   161,   161,   162,   162,   162,   162,   163,   164,
+     164,   165,   166,   167,   168,   168,   168,   168,   169,   170,
+     171,   172,   171,   174,   173,   175,   176,   176,   177,   179,
+     178,   180,   181,   181,   182,   182,   182,   182,   182,   182,
+     182,   182,   182,   182,   182,   182,   182,   182,   182,   182,
+     182,   182,   182,   182,   182,   182,   182,   182,   182,   182,
+     182,   182,   182,   182,   182,   182,   182,   182,   182,   183,
+     183,   183,   183,   183,   183,   183,   183,   183,   183,   184,
+     185,   185,   185,   186,   187,   187,   188,   188,   188,   188,
+     188,   188,   188,   188,   188,   188,   188,   188,   189,   189,
+     190,   190,   191,   191,   191,   191,   191,   191,   191,   191,
+     191,   191,   191,   191,   191,   191,   191,   191,   191,   191,
+     191,   191,   191,   191,   191,   191,   191,   191,   191,   191,
+     191,   191,   191,   191,   191,   191,   191,   191,   191
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     2,     1,     1,     6,     0,     9,     0,
+       1,     3,     2,     1,     1,     2,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     0,     2,     3,     2,     2,     1,
+       1,     3,     5,     4,     4,     3,     3,     4,     2,     1,
+       1,     1,     1,     1,     1,     1,     3,     2,     2,     1,
+       1,     1,     4,     3,     1,     3,     1,     3,     3,     5,
+       3,     0,     2,     2,     2,     4,     3,     5,     3,     1,
+       3,     2,     3,     5,     1,     1,     2,     2,     3,     4,
+       1,     0,     4,     0,     6,     2,     8,     7,     7,     0,
+       7,     0,     0,     1,     1,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     5,     1,     1,     2,     3,     3,     3,     2,
+       2,     2,     2,     2,     2,     4,     4,     2,     2,     6,
+       1,     1,     1,     3,     1,     3,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     2,
+       1,     2,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,   204,   202,   196,    19,    27,   205,   206,   198,   176,
+      32,   203,   197,    16,   208,   177,   178,   179,   180,   181,
+     182,    23,   199,   200,   201,   194,   172,    22,    17,   195,
+      18,   173,    29,    31,   175,   187,   193,    33,   190,   186,
+     188,   183,   184,   185,   189,   191,   174,   192,   207,    28,
+      30,     0,     2,     5,     4,     0,    25,    14,    26,    21,
+      24,    20,   168,     1,     3,     0,    15,   170,   169,     9,
+     171,     0,    10,    13,     0,     0,    12,    11,     6,     7,
+      34,    39,   156,   158,   157,   159,   160,   161,   162,   163,
+     164,   165,     0,     0,     0,     0,     0,    34,     0,     0,
+       0,     0,     0,   102,     0,     0,     0,     0,     0,     0,
+     101,    51,    50,     0,     0,   166,    40,    79,   134,    49,
+      34,    60,    61,    59,    55,    90,    52,   102,    54,    53,
+       0,   103,   133,   167,   104,     0,    81,     0,     0,     0,
+      37,    39,   148,     0,   166,   143,   144,    39,   147,   135,
+       0,     0,     0,   141,   140,    58,    57,     0,   102,     0,
+       0,     0,     0,     0,     0,    71,     0,     8,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,   142,
+     139,     0,    35,    91,    95,    48,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    38,    41,     0,     0,    63,
+       0,     0,    66,    64,     0,     0,     0,    80,   105,     0,
+       0,     0,   102,     0,    82,     0,    56,     0,     0,     0,
+       0,    71,    74,     0,    78,   131,   130,   129,   128,   127,
+     126,   124,   125,   123,   122,   121,    45,   102,     0,   120,
+     119,   137,   138,   136,   114,   113,   117,   118,   115,   116,
+     111,   112,   107,   106,   110,   109,   108,    36,    44,    46,
+       0,     0,     0,    62,    43,     0,     0,     0,   145,     0,
+      71,     0,   102,    93,   146,     0,     0,     0,    84,    85,
+       0,    73,    72,    76,    71,    92,     0,    70,    65,     0,
+      68,    67,    42,    47,     0,   151,   152,   150,     0,   154,
+       0,     0,   102,     0,   102,     0,    34,    83,    86,    87,
+      99,    71,    75,   132,     0,   150,     0,   149,     0,     0,
+     102,    94,    34,    88,   102,    77,    69,   153,   155,    98,
+      97,     0,    89,   100,    96
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,    51,    52,   111,   112,    80,    71,    72,   113,    56,
+      57,    58,    59,    60,   114,   115,   116,   140,   117,   118,
+     211,   306,   232,   166,   119,   120,   121,   122,   123,   287,
+     288,   289,   124,   247,   125,   314,   126,   127,   128,   129,
+     334,   164,   130,   131,   132,   133,   308,   309,   310,   134,
+      61,   135,    62
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -210
+static const yytype_int16 yypact[] =
+{
+    1438,  -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,
+    -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,
+    -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,
+    -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,
+    -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,
+    -210,   168,  -210,  -210,  -210,   651,  -210,  -210,  -210,  -210,
+    -210,  -210,    12,  -210,  -210,     2,  -210,  -210,    18,  1438,
+    -210,    -5,  -210,   726,  1438,    11,  -210,  -210,  -210,  -210,
+     304,    85,  -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,
+    -210,  -210,     7,   587,   587,  1378,  1378,   304,  1145,     7,
+       7,    40,    53,   440,    55,   114,    65,  1378,    66,  1378,
+    -210,  -210,  -210,   801,    75,    10,    76,  -210,  -210,  -210,
+     304,  -210,  -210,  -210,  -210,    45,  -210,   440,  -210,  -210,
+     121,  1765,  -210,  -210,  -210,    13,  -210,   137,  1378,  1278,
+      96,   101,  -210,  1510,  -210,  -210,  -210,    78,  -210,  -210,
+      98,   423,    82,  -210,  -210,  -210,  -210,    21,   576,   152,
+    1378,   996,  1510,  1701,   109,    84,    35,  -210,  1378,  1378,
+    1378,  1378,  1378,  1378,  1378,  1378,  1378,  1378,  1378,  -210,
+    -210,   170,  -210,  -210,  -210,  -210,  1378,  1378,  1378,  1378,
+    1378,  1378,  1378,  1378,  1378,  1378,  1378,  1378,  1378,  1378,
+    1378,  1378,  1378,  1378,  1378,   112,   112,  1645,  1297,  -210,
+     -11,    -2,  -210,  1765,   171,  1378,   120,  -210,  -210,  1439,
+     126,   876,  1378,   164,  -210,  1128,  -210,   122,   -48,  1378,
+    1359,    89,  -210,   185,  -210,  1765,  1765,  1765,  1765,  1765,
+    1765,  1765,  1765,  1765,  1765,  1765,  -210,   440,  1726,   289,
+    1781,  1796,  1810,  1823,   562,   562,   149,   149,   149,   149,
+     118,   118,    -6,    -6,  -210,  -210,  -210,   130,   130,  -210,
+      -4,  1378,  1297,  -210,   112,  1673,   129,  1012,  -210,  1378,
+      90,   182,  1378,  -210,  -210,  1378,   173,   -27,  -210,  -210,
+    1422,  -210,  1765,  -210,    90,  -210,  1378,  -210,  1765,    91,
+    -210,  1765,   130,  -210,  1297,   130,  -210,   423,   184,  -210,
+     141,  1615,  1378,   187,   440,  1746,   304,  -210,  -210,  -210,
+    -210,    89,  -210,  1765,  1378,  1765,  1297,  -210,   188,   146,
+    1378,  -210,   304,  -210,   440,  -210,  1765,   184,  -210,  -210,
+    -210,   147,  -210,  -210,  -210
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+    -210,  -210,   158,     8,     9,  -210,  -210,   138,    17,  -210,
+     -49,  -210,  -210,  -210,   -97,    30,  -210,  -118,  -210,  -210,
+       3,  -119,  -209,  -210,    57,  -100,  -210,  -210,  -210,  -210,
+     -74,   -71,  -210,  -210,  -210,  -210,  -210,  -210,  -210,  -210,
+    -210,  -210,  -151,   -94,  -210,  -210,  -109,  -210,  -108,   -40,
+     -93,   159,  -210
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -103
+static const yytype_int16 yytable[] =
+{
+     150,   148,   149,   157,   151,   152,    66,   223,    53,    54,
+     141,    74,   272,   161,   272,   163,   205,    55,   271,   285,
+     212,   210,   293,   182,    66,   286,   317,   184,    78,   168,
+     169,   170,   171,   172,   173,   174,   175,   176,   177,   178,
+     285,   202,   203,   204,   207,   213,   286,   231,   215,   297,
+     216,   233,   234,   145,   146,    75,    67,   155,   273,    53,
+      54,    67,    70,    69,    66,    79,   225,    70,    55,   227,
+     156,   281,   179,   180,   235,   236,   237,   238,   239,   240,
+     241,   242,   243,   244,   245,   322,    73,   267,   268,   212,
+     210,    73,   248,   249,   250,   251,   252,   253,   254,   255,
+     256,   257,   258,   259,   260,   261,   262,   263,   264,   265,
+     266,   291,   335,   230,   213,   136,   158,   159,   230,   230,
+     324,   275,   142,   144,   144,   278,   160,   162,   167,   153,
+     154,   313,   181,   183,   137,   290,   292,   138,   185,   139,
+     206,   137,   219,   138,   138,    69,   139,   295,   215,   138,
+     215,   217,   214,   300,   299,   215,   302,   137,   220,   305,
+     138,   329,   231,   200,   201,   202,   203,   204,    63,   224,
+     229,   138,    66,   246,   274,   221,   321,   298,   301,   341,
+     276,   282,   284,   307,   152,   311,   305,   279,   294,   215,
+     304,   315,   198,   199,   200,   201,   202,   203,   204,   312,
+     326,   327,   323,   316,   330,   339,   340,   344,   305,    64,
+     325,   270,    77,   318,   331,   222,   319,   337,   338,   333,
+       0,    68,     0,     0,     0,     0,     0,     0,     0,     0,
+     336,     0,   325,     1,   343,   342,     2,     3,     4,     5,
+       0,     0,     0,     6,     7,     8,     0,     9,    10,    11,
+      12,     0,    13,     0,    14,     0,     0,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
+      28,     0,    29,    30,    31,    32,    33,     0,     0,    34,
+      35,    36,     0,     0,     0,    37,     0,     0,     0,     0,
+      38,    39,     0,    40,    41,    42,    43,    44,    45,    46,
+       0,     0,    47,    48,    49,     0,    50,    81,    82,    83,
+      84,    85,    86,    87,    88,    89,    90,    91,     0,     0,
+       0,  -102,   188,   189,   190,   191,   192,   193,   194,   195,
+     196,   197,   198,   199,   200,   201,   202,   203,   204,     0,
+      92,     0,     0,     0,     0,     0,     0,     0,     0,    93,
+      94,     0,     0,    67,    95,    96,     0,     0,    97,     0,
+       0,     0,     0,     0,     0,    98,    99,   100,     0,     1,
+     101,     0,     2,     3,     4,     5,   102,     0,   103,     6,
+       7,     8,     0,     9,    10,    11,    12,   104,    13,   105,
+      14,   106,     0,    15,    16,    17,    18,    19,    20,    21,
+      22,    23,    24,    25,    26,    27,    28,     0,    29,    30,
+      31,    32,    33,     0,   107,    34,    35,    36,     0,   108,
+       0,    37,     0,   109,     0,     0,    38,    39,     0,    40,
+      41,    42,    43,    44,    45,    46,     0,     0,    47,    48,
+      49,   110,    50,    81,    82,    83,    84,    85,    86,    87,
+      88,    89,    90,    91,   186,   187,   188,   189,   190,   191,
+     192,   193,   194,   195,   196,   197,   198,   199,   200,   201,
+     202,   203,   204,     0,     0,     0,    92,     0,     0,     0,
+       0,     0,     0,   218,     0,    93,    94,     0,     0,    67,
+      95,    96,     0,     0,    97,     0,     0,     0,     0,     0,
+       0,    98,    99,   100,     0,     1,   101,     0,     2,     3,
+       4,     5,   102,     0,   103,     6,     7,     8,     0,     9,
+      10,    11,    12,   104,    13,   105,    14,   106,     0,    15,
+      16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
+      26,    27,    28,     0,    29,    30,    31,    32,    33,     0,
+     107,    34,    35,    36,     0,   108,     0,    37,     0,   109,
+       0,     0,    38,    39,     0,    40,    41,    42,    43,    44,
+      45,    46,     0,     0,    47,    48,    49,   110,    50,   147,
+      82,    83,    84,    85,    86,    87,    88,    89,    90,    91,
+     141,    82,    83,    84,    85,    86,    87,    88,    89,    90,
+      91,   194,   195,   196,   197,   198,   199,   200,   201,   202,
+     203,   204,    92,     0,     0,     0,     0,     0,     0,     0,
+       0,    93,    94,     0,     0,    67,    95,    96,     0,     0,
+       0,     0,     0,     0,     0,     0,    67,    98,    99,   100,
+       0,     1,     0,     0,     2,     3,     4,     5,   143,     0,
+       0,     6,     7,     8,    65,     9,    10,    11,    12,     0,
+      13,     0,    14,     0,     0,    15,    16,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,     0,
+      29,    30,    31,    32,    33,     0,     0,    34,    35,    36,
+       0,   108,     0,    37,     0,     0,     0,     0,    38,    39,
+       0,    40,    41,    42,    43,    44,    45,    46,     0,     0,
+      47,    48,    49,     0,    50,     0,     1,     0,     0,     2,
+       3,     4,     5,     0,     0,     0,     6,     7,     8,    76,
+       9,    10,    11,    12,     0,    13,     0,    14,     0,     0,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,     0,    29,    30,    31,    32,    33,
+       0,     0,    34,    35,    36,     0,     0,     0,    37,     0,
+       0,     0,     0,    38,    39,     0,    40,    41,    42,    43,
+      44,    45,    46,     0,     0,    47,    48,    49,     0,    50,
+       0,     1,     0,     0,     2,     3,     4,     5,     0,     0,
+       0,     6,     7,     8,   165,     9,    10,    11,    12,     0,
+      13,     0,    14,     0,     0,    15,    16,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,     0,
+      29,    30,    31,    32,    33,     0,     0,    34,    35,    36,
+       0,     0,     0,    37,     0,     0,     0,     0,    38,    39,
+       0,    40,    41,    42,    43,    44,    45,    46,     0,     0,
+      47,    48,    49,     0,    50,     0,     1,     0,     0,     2,
+       3,     4,     5,     0,     0,     0,     6,     7,     8,   280,
+       9,    10,    11,    12,     0,    13,     0,    14,     0,     0,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,     0,    29,    30,    31,    32,    33,
+       0,     0,    34,    35,    36,     0,     0,     0,    37,     0,
+       0,     0,     0,    38,    39,     0,    40,    41,    42,    43,
+      44,    45,    46,     0,     0,    47,    48,    49,     0,    50,
+       0,     1,     0,     0,     2,     3,     4,     5,     0,     0,
+       0,     6,     7,     8,     0,     9,    10,    11,    12,     0,
+      13,     0,    14,     0,     0,    15,    16,    17,    18,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,     0,
+      29,    30,    31,    32,    33,     0,     0,    34,    35,    36,
+       0,     0,     0,    37,     0,     0,     0,     0,    38,    39,
+       0,    40,    41,    42,    43,    44,    45,    46,     0,     0,
+      47,    48,    49,   226,    50,   147,    82,    83,    84,    85,
+      86,    87,    88,    89,    90,    91,     0,   186,   187,   188,
+     189,   190,   191,   192,   193,   194,   195,   196,   197,   198,
+     199,   200,   201,   202,   203,   204,     0,     0,    92,     0,
+       0,     0,     0,     0,     0,     0,     0,    93,    94,     0,
+       0,    67,    95,    96,     0,     0,   208,     0,     0,     0,
+       0,   138,     0,    98,    99,   100,     0,     1,     0,     0,
+       2,     3,     0,     0,     0,     0,     0,     6,     7,     8,
+       0,     9,     0,    11,    12,     0,     0,     0,    14,     0,
+       0,    15,    16,    17,    18,    19,    20,     0,    22,    23,
+      24,    25,    26,     0,     0,     0,    29,     0,    31,     0,
+       0,     0,     0,    34,    35,    36,     0,   108,     0,     0,
+       0,     0,     0,     0,    38,    39,     0,    40,    41,    42,
+      43,    44,    45,    46,     0,     0,    47,    48,   147,    82,
+      83,    84,    85,    86,    87,    88,    89,    90,    91,   186,
+     187,   188,   189,   190,   191,   192,   193,   194,   195,   196,
+     197,   198,   199,   200,   201,   202,   203,   204,     0,     0,
+       0,    92,     0,     0,     0,     0,     0,     0,   283,     0,
+      93,    94,     0,     0,    67,    95,    96,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    98,    99,   100,     0,
+       1,     0,     0,     2,     3,     0,     0,     0,     0,     0,
+       6,     7,     8,     0,     9,     0,    11,    12,     0,     0,
+       0,    14,     0,     0,    15,    16,    17,    18,    19,    20,
+       0,    22,    23,    24,    25,    26,     0,     0,     0,    29,
+       0,    31,     0,     0,     0,     0,    34,    35,    36,     0,
+     108,     0,     0,     0,     0,     0,     0,    38,    39,     0,
+      40,    41,    42,    43,    44,    45,    46,     0,     0,    47,
+      48,   147,    82,    83,    84,    85,    86,    87,    88,    89,
+      90,    91,     0,     0,     0,     0,     0,     0,     0,     0,
+     147,    82,    83,    84,    85,    86,    87,    88,    89,    90,
+      91,     0,     0,     0,    92,     0,     0,     0,     0,     0,
+       0,     0,     0,    93,    94,     0,     0,    67,    95,    96,
+       0,     0,   208,    92,     0,     0,     0,   138,   209,    98,
+      99,   100,    93,    94,     0,     0,    67,    95,    96,     0,
+       0,   208,     0,     0,     0,     0,   138,     0,    98,    99,
+     100,     0,   147,    82,    83,    84,    85,    86,    87,    88,
+      89,    90,    91,     0,     0,     0,     0,     0,     0,     0,
+       0,   147,    82,    83,    84,    85,    86,    87,    88,    89,
+      90,    91,     0,   108,     0,    92,     0,     0,     0,     0,
+       0,     0,     0,     0,    93,    94,     0,     0,    67,    95,
+      96,     0,   108,   208,    92,     0,     0,     0,     0,     0,
+      98,    99,   100,    93,    94,     0,     0,    67,    95,    96,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    98,
+      99,   100,   147,    82,    83,    84,    85,    86,    87,    88,
+      89,    90,    91,   186,   187,   188,   189,   190,   191,   192,
+     193,   194,   195,   196,   197,   198,   199,   200,   201,   202,
+     203,   204,     0,     0,   108,    92,     0,     0,     0,     0,
+       0,     0,   320,     0,    93,    94,     0,     0,    67,    95,
+      96,     0,     0,   108,     0,     0,     0,     0,     0,     0,
+     277,    99,   100,     1,     0,     0,     2,     3,     4,     5,
+       0,     0,     0,     6,     7,     8,     0,     9,    10,    11,
+      12,     0,    13,     0,    14,     0,     0,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
+      28,     0,    29,    30,    31,    32,    33,     0,     0,    34,
+      35,    36,     0,     0,   108,    37,     0,     0,     0,     0,
+      38,    39,     0,    40,    41,    42,    43,    44,    45,    46,
+       0,     0,    47,    48,    49,     1,    50,     0,     2,     3,
+       0,     0,     0,     0,     0,     6,     7,     8,     0,     9,
+       0,    11,    12,     0,     0,     0,    14,     0,     0,    15,
+      16,    17,    18,    19,    20,     0,    22,    23,    24,    25,
+      26,     0,     0,     0,    29,     0,    31,     0,     0,     0,
+       0,    34,    35,    36,     0,     0,     0,     0,     0,     0,
+       0,     0,    38,    39,     0,    40,    41,    42,    43,    44,
+      45,    46,     0,     0,    47,    48,   186,   187,   188,   189,
+     190,   191,   192,   193,   194,   195,   196,   197,   198,   199,
+     200,   201,   202,   203,   204,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,   328,   186,   187,   188,   189,
+     190,   191,   192,   193,   194,   195,   196,   197,   198,   199,
+     200,   201,   202,   203,   204,     0,     0,     0,     0,     0,
+       0,     0,     0,   269,   186,   187,   188,   189,   190,   191,
+     192,   193,   194,   195,   196,   197,   198,   199,   200,   201,
+     202,   203,   204,     0,     0,     0,     0,     0,     0,     0,
+       0,   303,   186,   187,   188,   189,   190,   191,   192,   193,
+     194,   195,   196,   197,   198,   199,   200,   201,   202,   203,
+     204,     0,     0,     0,     0,   228,   296,   186,   187,   188,
+     189,   190,   191,   192,   193,   194,   195,   196,   197,   198,
+     199,   200,   201,   202,   203,   204,   332,   186,   187,   188,
+     189,   190,   191,   192,   193,   194,   195,   196,   197,   198,
+     199,   200,   201,   202,   203,   204,   186,   187,   188,   189,
+     190,   191,   192,   193,   194,   195,   196,   197,   198,   199,
+     200,   201,   202,   203,   204,   189,   190,   191,   192,   193,
+     194,   195,   196,   197,   198,   199,   200,   201,   202,   203,
+     204,   190,   191,   192,   193,   194,   195,   196,   197,   198,
+     199,   200,   201,   202,   203,   204,   191,   192,   193,   194,
+     195,   196,   197,   198,   199,   200,   201,   202,   203,   204,
+     192,   193,   194,   195,   196,   197,   198,   199,   200,   201,
+     202,   203,   204
+};
+
+#define yypact_value_is_default(yystate) \
+  ((yystate) == (-210))
+
+#define yytable_value_is_error(yytable_value) \
+  YYID (0)
+
+static const yytype_int16 yycheck[] =
+{
+      97,    95,    96,   103,    98,    98,    55,   158,     0,     0,
+       3,    16,    16,   107,    16,   109,     3,     0,    29,    67,
+     139,   139,   231,   120,    73,    73,    53,   127,    17,    19,
+      20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
+      67,    47,    48,    49,   138,   139,    73,   165,    59,    53,
+     143,    16,    17,    93,    94,    60,    49,    17,    60,    51,
+      51,    49,    49,    61,   113,    54,   160,    49,    51,   162,
+      17,   222,    62,    63,   168,   169,   170,   171,   172,   173,
+     174,   175,   176,   177,   178,   294,    69,   205,   206,   208,
+     208,    74,   186,   187,   188,   189,   190,   191,   192,   193,
+     194,   195,   196,   197,   198,   199,   200,   201,   202,   203,
+     204,   230,   321,    29,   208,    30,    61,     3,    29,    29,
+      29,   215,    92,    93,    94,   219,    61,    61,    53,    99,
+     100,   282,    56,    88,    56,   229,   230,    59,    17,    61,
+       3,    56,    60,    59,    59,    61,    61,   247,    59,    59,
+      59,    53,    56,   272,   272,    59,   274,    56,   137,   277,
+      59,   312,   280,    45,    46,    47,    48,    49,     0,    17,
+      61,    59,   221,     3,     3,   158,   294,   271,   272,   330,
+      60,    17,    60,   277,   277,   279,   304,    61,     3,    59,
+      61,   285,    43,    44,    45,    46,    47,    48,    49,    17,
+      16,    60,   296,    30,    17,    17,    60,    60,   326,    51,
+     304,   208,    74,   287,   314,   158,   287,   326,   326,   316,
+      -1,    62,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+     324,    -1,   326,    65,   334,   332,    68,    69,    70,    71,
+      -1,    -1,    -1,    75,    76,    77,    -1,    79,    80,    81,
+      82,    -1,    84,    -1,    86,    -1,    -1,    89,    90,    91,
+      92,    93,    94,    95,    96,    97,    98,    99,   100,   101,
+     102,    -1,   104,   105,   106,   107,   108,    -1,    -1,   111,
+     112,   113,    -1,    -1,    -1,   117,    -1,    -1,    -1,    -1,
+     122,   123,    -1,   125,   126,   127,   128,   129,   130,   131,
+      -1,    -1,   134,   135,   136,    -1,   138,     3,     4,     5,
+       6,     7,     8,     9,    10,    11,    12,    13,    -1,    -1,
+      -1,    17,    33,    34,    35,    36,    37,    38,    39,    40,
+      41,    42,    43,    44,    45,    46,    47,    48,    49,    -1,
+      36,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    45,
+      46,    -1,    -1,    49,    50,    51,    -1,    -1,    54,    -1,
+      -1,    -1,    -1,    -1,    -1,    61,    62,    63,    -1,    65,
+      66,    -1,    68,    69,    70,    71,    72,    -1,    74,    75,
+      76,    77,    -1,    79,    80,    81,    82,    83,    84,    85,
+      86,    87,    -1,    89,    90,    91,    92,    93,    94,    95,
+      96,    97,    98,    99,   100,   101,   102,    -1,   104,   105,
+     106,   107,   108,    -1,   110,   111,   112,   113,    -1,   115,
+      -1,   117,    -1,   119,    -1,    -1,   122,   123,    -1,   125,
+     126,   127,   128,   129,   130,   131,    -1,    -1,   134,   135,
+     136,   137,   138,     3,     4,     5,     6,     7,     8,     9,
+      10,    11,    12,    13,    31,    32,    33,    34,    35,    36,
+      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,
+      47,    48,    49,    -1,    -1,    -1,    36,    -1,    -1,    -1,
+      -1,    -1,    -1,    60,    -1,    45,    46,    -1,    -1,    49,
+      50,    51,    -1,    -1,    54,    -1,    -1,    -1,    -1,    -1,
+      -1,    61,    62,    63,    -1,    65,    66,    -1,    68,    69,
+      70,    71,    72,    -1,    74,    75,    76,    77,    -1,    79,
+      80,    81,    82,    83,    84,    85,    86,    87,    -1,    89,
+      90,    91,    92,    93,    94,    95,    96,    97,    98,    99,
+     100,   101,   102,    -1,   104,   105,   106,   107,   108,    -1,
+     110,   111,   112,   113,    -1,   115,    -1,   117,    -1,   119,
+      -1,    -1,   122,   123,    -1,   125,   126,   127,   128,   129,
+     130,   131,    -1,    -1,   134,   135,   136,   137,   138,     3,
+       4,     5,     6,     7,     8,     9,    10,    11,    12,    13,
+       3,     4,     5,     6,     7,     8,     9,    10,    11,    12,
+      13,    39,    40,    41,    42,    43,    44,    45,    46,    47,
+      48,    49,    36,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    45,    46,    -1,    -1,    49,    50,    51,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    49,    61,    62,    63,
+      -1,    65,    -1,    -1,    68,    69,    70,    71,    61,    -1,
+      -1,    75,    76,    77,     3,    79,    80,    81,    82,    -1,
+      84,    -1,    86,    -1,    -1,    89,    90,    91,    92,    93,
+      94,    95,    96,    97,    98,    99,   100,   101,   102,    -1,
+     104,   105,   106,   107,   108,    -1,    -1,   111,   112,   113,
+      -1,   115,    -1,   117,    -1,    -1,    -1,    -1,   122,   123,
+      -1,   125,   126,   127,   128,   129,   130,   131,    -1,    -1,
+     134,   135,   136,    -1,   138,    -1,    65,    -1,    -1,    68,
+      69,    70,    71,    -1,    -1,    -1,    75,    76,    77,     3,
+      79,    80,    81,    82,    -1,    84,    -1,    86,    -1,    -1,
+      89,    90,    91,    92,    93,    94,    95,    96,    97,    98,
+      99,   100,   101,   102,    -1,   104,   105,   106,   107,   108,
+      -1,    -1,   111,   112,   113,    -1,    -1,    -1,   117,    -1,
+      -1,    -1,    -1,   122,   123,    -1,   125,   126,   127,   128,
+     129,   130,   131,    -1,    -1,   134,   135,   136,    -1,   138,
+      -1,    65,    -1,    -1,    68,    69,    70,    71,    -1,    -1,
+      -1,    75,    76,    77,     3,    79,    80,    81,    82,    -1,
+      84,    -1,    86,    -1,    -1,    89,    90,    91,    92,    93,
+      94,    95,    96,    97,    98,    99,   100,   101,   102,    -1,
+     104,   105,   106,   107,   108,    -1,    -1,   111,   112,   113,
+      -1,    -1,    -1,   117,    -1,    -1,    -1,    -1,   122,   123,
+      -1,   125,   126,   127,   128,   129,   130,   131,    -1,    -1,
+     134,   135,   136,    -1,   138,    -1,    65,    -1,    -1,    68,
+      69,    70,    71,    -1,    -1,    -1,    75,    76,    77,     3,
+      79,    80,    81,    82,    -1,    84,    -1,    86,    -1,    -1,
+      89,    90,    91,    92,    93,    94,    95,    96,    97,    98,
+      99,   100,   101,   102,    -1,   104,   105,   106,   107,   108,
+      -1,    -1,   111,   112,   113,    -1,    -1,    -1,   117,    -1,
+      -1,    -1,    -1,   122,   123,    -1,   125,   126,   127,   128,
+     129,   130,   131,    -1,    -1,   134,   135,   136,    -1,   138,
+      -1,    65,    -1,    -1,    68,    69,    70,    71,    -1,    -1,
+      -1,    75,    76,    77,    -1,    79,    80,    81,    82,    -1,
+      84,    -1,    86,    -1,    -1,    89,    90,    91,    92,    93,
+      94,    95,    96,    97,    98,    99,   100,   101,   102,    -1,
+     104,   105,   106,   107,   108,    -1,    -1,   111,   112,   113,
+      -1,    -1,    -1,   117,    -1,    -1,    -1,    -1,   122,   123,
+      -1,   125,   126,   127,   128,   129,   130,   131,    -1,    -1,
+     134,   135,   136,    17,   138,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    12,    13,    -1,    31,    32,    33,
+      34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
+      44,    45,    46,    47,    48,    49,    -1,    -1,    36,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    45,    46,    -1,
+      -1,    49,    50,    51,    -1,    -1,    54,    -1,    -1,    -1,
+      -1,    59,    -1,    61,    62,    63,    -1,    65,    -1,    -1,
+      68,    69,    -1,    -1,    -1,    -1,    -1,    75,    76,    77,
+      -1,    79,    -1,    81,    82,    -1,    -1,    -1,    86,    -1,
+      -1,    89,    90,    91,    92,    93,    94,    -1,    96,    97,
+      98,    99,   100,    -1,    -1,    -1,   104,    -1,   106,    -1,
+      -1,    -1,    -1,   111,   112,   113,    -1,   115,    -1,    -1,
+      -1,    -1,    -1,    -1,   122,   123,    -1,   125,   126,   127,
+     128,   129,   130,   131,    -1,    -1,   134,   135,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    31,
+      32,    33,    34,    35,    36,    37,    38,    39,    40,    41,
+      42,    43,    44,    45,    46,    47,    48,    49,    -1,    -1,
+      -1,    36,    -1,    -1,    -1,    -1,    -1,    -1,    60,    -1,
+      45,    46,    -1,    -1,    49,    50,    51,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    61,    62,    63,    -1,
+      65,    -1,    -1,    68,    69,    -1,    -1,    -1,    -1,    -1,
+      75,    76,    77,    -1,    79,    -1,    81,    82,    -1,    -1,
+      -1,    86,    -1,    -1,    89,    90,    91,    92,    93,    94,
+      -1,    96,    97,    98,    99,   100,    -1,    -1,    -1,   104,
+      -1,   106,    -1,    -1,    -1,    -1,   111,   112,   113,    -1,
+     115,    -1,    -1,    -1,    -1,    -1,    -1,   122,   123,    -1,
+     125,   126,   127,   128,   129,   130,   131,    -1,    -1,   134,
+     135,     3,     4,     5,     6,     7,     8,     9,    10,    11,
+      12,    13,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+       3,     4,     5,     6,     7,     8,     9,    10,    11,    12,
+      13,    -1,    -1,    -1,    36,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    45,    46,    -1,    -1,    49,    50,    51,
+      -1,    -1,    54,    36,    -1,    -1,    -1,    59,    60,    61,
+      62,    63,    45,    46,    -1,    -1,    49,    50,    51,    -1,
+      -1,    54,    -1,    -1,    -1,    -1,    59,    -1,    61,    62,
+      63,    -1,     3,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,     3,     4,     5,     6,     7,     8,     9,    10,    11,
+      12,    13,    -1,   115,    -1,    36,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    45,    46,    -1,    -1,    49,    50,
+      51,    -1,   115,    54,    36,    -1,    -1,    -1,    -1,    -1,
+      61,    62,    63,    45,    46,    -1,    -1,    49,    50,    51,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    61,
+      62,    63,     3,     4,     5,     6,     7,     8,     9,    10,
+      11,    12,    13,    31,    32,    33,    34,    35,    36,    37,
+      38,    39,    40,    41,    42,    43,    44,    45,    46,    47,
+      48,    49,    -1,    -1,   115,    36,    -1,    -1,    -1,    -1,
+      -1,    -1,    60,    -1,    45,    46,    -1,    -1,    49,    50,
+      51,    -1,    -1,   115,    -1,    -1,    -1,    -1,    -1,    -1,
+      61,    62,    63,    65,    -1,    -1,    68,    69,    70,    71,
+      -1,    -1,    -1,    75,    76,    77,    -1,    79,    80,    81,
+      82,    -1,    84,    -1,    86,    -1,    -1,    89,    90,    91,
+      92,    93,    94,    95,    96,    97,    98,    99,   100,   101,
+     102,    -1,   104,   105,   106,   107,   108,    -1,    -1,   111,
+     112,   113,    -1,    -1,   115,   117,    -1,    -1,    -1,    -1,
+     122,   123,    -1,   125,   126,   127,   128,   129,   130,   131,
+      -1,    -1,   134,   135,   136,    65,   138,    -1,    68,    69,
+      -1,    -1,    -1,    -1,    -1,    75,    76,    77,    -1,    79,
+      -1,    81,    82,    -1,    -1,    -1,    86,    -1,    -1,    89,
+      90,    91,    92,    93,    94,    -1,    96,    97,    98,    99,
+     100,    -1,    -1,    -1,   104,    -1,   106,    -1,    -1,    -1,
+      -1,   111,   112,   113,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,   122,   123,    -1,   125,   126,   127,   128,   129,
+     130,   131,    -1,    -1,   134,   135,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    60,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    58,    31,    32,    33,    34,    35,    36,
+      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,
+      47,    48,    49,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    58,    31,    32,    33,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    46,    47,    48,
+      49,    -1,    -1,    -1,    -1,    54,    30,    31,    32,    33,
+      34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
+      44,    45,    46,    47,    48,    49,    30,    31,    32,    33,
+      34,    35,    36,    37,    38,    39,    40,    41,    42,    43,
+      44,    45,    46,    47,    48,    49,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    34,    35,    36,    37,    38,
+      39,    40,    41,    42,    43,    44,    45,    46,    47,    48,
+      49,    35,    36,    37,    38,    39,    40,    41,    42,    43,
+      44,    45,    46,    47,    48,    49,    36,    37,    38,    39,
+      40,    41,    42,    43,    44,    45,    46,    47,    48,    49,
+      37,    38,    39,    40,    41,    42,    43,    44,    45,    46,
+      47,    48,    49
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,    65,    68,    69,    70,    71,    75,    76,    77,    79,
+      80,    81,    82,    84,    86,    89,    90,    91,    92,    93,
+      94,    95,    96,    97,    98,    99,   100,   101,   102,   104,
+     105,   106,   107,   108,   111,   112,   113,   117,   122,   123,
+     125,   126,   127,   128,   129,   130,   131,   134,   135,   136,
+     138,   140,   141,   142,   143,   147,   148,   149,   150,   151,
+     152,   189,   191,     0,   141,     3,   149,    49,   190,    61,
+      49,   145,   146,   147,    16,    60,     3,   146,    17,    54,
+     144,     3,     4,     5,     6,     7,     8,     9,    10,    11,
+      12,    13,    36,    45,    46,    50,    51,    54,    61,    62,
+      63,    66,    72,    74,    83,    85,    87,   110,   115,   119,
+     137,   142,   143,   147,   153,   154,   155,   157,   158,   163,
+     164,   165,   166,   167,   171,   173,   175,   176,   177,   178,
+     181,   182,   183,   184,   188,   190,    30,    56,    59,    61,
+     156,     3,   154,    61,   154,   188,   188,     3,   182,   182,
+     153,   182,   189,   154,   154,    17,    17,   164,    61,     3,
+      61,   182,    61,   182,   180,     3,   162,    53,    19,    20,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    62,
+      63,    56,   153,    88,   164,    17,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,     3,     3,   182,    54,    60,
+     156,   159,   160,   182,    56,    59,   189,    53,    60,    60,
+     137,   147,   163,   181,    17,   182,    17,   189,    54,    61,
+      29,   156,   161,    16,    17,   182,   182,   182,   182,   182,
+     182,   182,   182,   182,   182,   182,     3,   172,   182,   182,
+     182,   182,   182,   182,   182,   182,   182,   182,   182,   182,
+     182,   182,   182,   182,   182,   182,   182,   156,   156,    58,
+     159,    29,    16,    60,     3,   182,    60,    61,   182,    61,
+       3,   181,    17,    60,    60,    67,    73,   168,   169,   170,
+     182,   160,   182,   161,     3,   164,    30,    53,   182,   156,
+     160,   182,   156,    58,    61,   156,   160,   182,   185,   186,
+     187,   182,    17,   181,   174,   182,    30,    53,   169,   170,
+      60,   156,   161,   182,    29,   182,    16,    60,    60,   181,
+      17,   164,    30,   153,   179,   161,   182,   185,   187,    17,
+      60,   181,   153,   164,    60
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
+
+#define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* This macro is provided for backward compatibility. */
+
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
+                yytype_int16 *yyssp, int yytoken)
+{
+  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);
+  YYSIZE_T yysize = yysize0;
+  YYSIZE_T yysize1;
+  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = 0;
+  /* Arguments of yyformat. */
+  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+  /* Number of reported tokens (one for the "unexpected", one per
+     "expected"). */
+  int yycount = 0;
+
+  /* There are many possibilities here to consider:
+     - Assume YYFAIL is not used.  It's too flawed to consider.  See
+       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
+       for details.  YYERROR is fine as it does not invoke this
+       function.
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yytoken != YYEMPTY)
+    {
+      int yyn = yypact[*yyssp];
+      yyarg[yycount++] = yytname[yytoken];
+      if (!yypact_value_is_default (yyn))
+        {
+          /* Start YYX at -YYN if negative to avoid negative indexes in
+             YYCHECK.  In other words, skip the first -YYN actions for
+             this state because they are default actions.  */
+          int yyxbegin = yyn < 0 ? -yyn : 0;
+          /* Stay within bounds of both yycheck and yytname.  */
+          int yychecklim = YYLAST - yyn + 1;
+          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+          int yyx;
+
+          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
+                && !yytable_value_is_error (yytable[yyx + yyn]))
+              {
+                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+                  {
+                    yycount = 1;
+                    yysize = yysize0;
+                    break;
+                  }
+                yyarg[yycount++] = yytname[yyx];
+                yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+                if (! (yysize <= yysize1
+                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+                  return 2;
+                yysize = yysize1;
+              }
+        }
+    }
+
+  switch (yycount)
+    {
+# define YYCASE_(N, S)                      \
+      case N:                               \
+        yyformat = S;                       \
+      break
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+# undef YYCASE_
+    }
+
+  yysize1 = yysize + yystrlen (yyformat);
+  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
+    return 2;
+  yysize = yysize1;
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return 1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yyarg[yyi++]);
+          yyformat += 2;
+        }
+      else
+        {
+          yyp++;
+          yyformat++;
+        }
+  }
+  return 0;
+}
+#endif /* YYERROR_VERBOSE */
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+
+/* Line 1806 of yacc.c  */
+#line 203 "parser.y"
+    {printf("start rule matched\n");}
+    break;
+
+  case 3:
+
+/* Line 1806 of yacc.c  */
+#line 204 "parser.y"
+    {printf("start rule matched\n");}
+    break;
+
+  case 7:
+
+/* Line 1806 of yacc.c  */
+#line 218 "parser.y"
+    {
+		int err;
+		struct cl2llvm_function_t *new_function;
+	
+		snprintf(block_name, sizeof block_name,
+			"block_%d", block_count++);
+		
+		/*Read function arguments*/
+		int arg_count = list_count((yyvsp[(4) - (6)].arg_list));
+		int arg_num;
+		LLVMTypeRef func_args[2];
+		if (list_get((yyvsp[(4) - (6)].arg_list), (yyvsp[(4) - (6)].arg_list)->head) == NULL)
+		{
+			if (arg_count > 1)
+				yyerror("expected declaration specifiers or '...' before ',' token");
+			else 
+			{
+				func_args[0] = NULL;
+			}
+		}
+		else
+		{
+			for (arg_num = 0; arg_num < arg_count; arg_num++)
+			{
+				printf("loop1\n");
+				
+				struct cl2llvm_arg_t *current_arg = list_get((yyvsp[(4) - (6)].arg_list), arg_num);
+				/*LLVMGetTypeKind(current_arg->type_spec->llvm_type);*/
+				if (current_arg->name == NULL)
+					yyerror("parameter name omitted");
+				func_args[arg_num] = current_arg->type_spec->llvm_type;
+			}
+			func_args[arg_num + 1] = NULL;
+		}
+
+
+		LLVMTypeRef cl2llvm_function_type = LLVMFunctionType((yyvsp[(1) - (6)].decl_list)->type_spec->llvm_type, func_args, arg_count, 0);
+		LLVMValueRef cl2llvm_function = LLVMAddFunction(cl2llvm_module, (yyvsp[(2) - (6)].identifier),
+			cl2llvm_function_type);
+		LLVMSetFunctionCallConv(cl2llvm_function, LLVMCCallConv);
+		LLVMBasicBlockRef cl2llvm_basic_block = LLVMAppendBasicBlock(cl2llvm_function, block_name);
+		new_function = cl2llvm_function_create((yyvsp[(2) - (6)].identifier), (yyvsp[(4) - (6)].arg_list));
+
+		current_function = new_function;
+
+		LLVMPositionBuilderAtEnd(cl2llvm_builder, cl2llvm_basic_block);
+		
+		new_function->func = cl2llvm_function;
+		new_function->func_type = cl2llvm_function_type;
+		new_function->sign = (yyvsp[(1) - (6)].decl_list)->type_spec->sign;
+
+		/*insert function into global symbol table*/
+		err = hash_table_insert(cl2llvm_symbol_table, 
+			(yyvsp[(2) - (6)].identifier), new_function);
+		printf("%s\n", (yyvsp[(2) - (6)].identifier));
+		if (!err)
+			printf("function already defined");
+		/* Declare parameters */
+		if (list_get((yyvsp[(4) - (6)].arg_list), (yyvsp[(4) - (6)].arg_list)->head) != NULL)
+		{
+			for (arg_num = 0; arg_num < arg_count; arg_num++)
+			{
+				
+				struct cl2llvm_arg_t *current_arg = list_get((yyvsp[(4) - (6)].arg_list), arg_num);			
+				LLVMGetTypeKind(current_arg->type_spec->llvm_type);
+				struct cl2llvm_val_t *arg_pointer = cl2llvm_val_create_w_init( 
+					LLVMBuildAlloca(cl2llvm_builder, 
+					current_arg->type_spec->llvm_type, current_arg->name),
+					current_arg->type_spec->sign);
+				struct cl2llvm_symbol_t *symbol = cl2llvm_symbol_create_w_init( 
+					arg_pointer->val, current_arg->type_spec->sign, current_arg->name);
+				symbol->cl2llvm_val->type->llvm_type = current_arg->type_spec->llvm_type;
+				LLVMValueRef arg_val = LLVMGetParam(new_function->func, arg_num);
+				LLVMBuildStore(cl2llvm_builder, arg_val, arg_pointer->val);
+				hash_table_insert(new_function->symbol_table, current_arg->name, symbol);
+				cl2llvm_val_free(arg_pointer);
+			}
+		}
+		cl2llvm_decl_list_free((yyvsp[(1) - (6)].decl_list));	
+	}
+    break;
+
+  case 8:
+
+/* Line 1806 of yacc.c  */
+#line 299 "parser.y"
+    {
+		if (LLVMGetReturnType(current_function->func_type) == LLVMVoidType())
+			LLVMBuildRetVoid(cl2llvm_builder);
+	}
+    break;
+
+  case 9:
+
+/* Line 1806 of yacc.c  */
+#line 309 "parser.y"
+    {
+		printf("empty\n");
+		struct cl2llvm_arg_t *empty_arg = NULL;
+		struct list_t *arg_list = list_create();
+		list_add(arg_list, empty_arg);
+		(yyval.arg_list) = arg_list;
+	}
+    break;
+
+  case 10:
+
+/* Line 1806 of yacc.c  */
+#line 317 "parser.y"
+    {
+		printf("arg\n");
+		struct list_t *arg_list = list_create();
+		list_add(arg_list, (yyvsp[(1) - (1)].arg_t));
+		(yyval.arg_list) = arg_list;
+	}
+    break;
+
+  case 11:
+
+/* Line 1806 of yacc.c  */
+#line 324 "parser.y"
+    {
+		printf("arg_list\n");
+		list_add((yyvsp[(1) - (3)].arg_list), (yyvsp[(3) - (3)].arg_t));
+		(yyval.arg_list) = (yyvsp[(1) - (3)].arg_list);
+	}
+    break;
+
+  case 12:
+
+/* Line 1806 of yacc.c  */
+#line 333 "parser.y"
+    {
+		struct cl2llvm_arg_t *arg = cl2llvm_arg_create((yyvsp[(1) - (2)].decl_list), (yyvsp[(2) - (2)].identifier));
+		cl2llvm_decl_list_struct_free((yyvsp[(1) - (2)].decl_list));
+		(yyval.arg_t) = arg;
+	}
+    break;
+
+  case 13:
+
+/* Line 1806 of yacc.c  */
+#line 339 "parser.y"
+    {
+		struct cl2llvm_arg_t *arg = cl2llvm_arg_create((yyvsp[(1) - (1)].decl_list), NULL);
+		cl2llvm_decl_list_struct_free((yyvsp[(1) - (1)].decl_list));
+		(yyval.arg_t) = arg;
+	}
+    break;
+
+  case 14:
+
+/* Line 1806 of yacc.c  */
+#line 350 "parser.y"
+    {
+		(yyval.decl_list) = (yyvsp[(1) - (1)].decl_list);
+	}
+    break;
+
+  case 15:
+
+/* Line 1806 of yacc.c  */
+#line 354 "parser.y"
+    {
+		cl2llvm_attach_decl_to_list((yyvsp[(2) - (2)].decl_list), (yyvsp[(1) - (2)].decl_list));
+		cl2llvm_decl_list_struct_free((yyvsp[(2) - (2)].decl_list));
+		(yyval.decl_list) = (yyvsp[(1) - (2)].decl_list);
+	}
+    break;
+
+  case 20:
+
+/* Line 1806 of yacc.c  */
+#line 370 "parser.y"
+    {
+		struct cl2llvm_decl_list_t *decl_list = cl2llvm_decl_list_create();
+		decl_list->type_spec = (yyvsp[(1) - (1)].llvm_type_ref);
+		(yyval.decl_list) = decl_list;
+	}
+    break;
+
+  case 21:
+
+/* Line 1806 of yacc.c  */
+#line 376 "parser.y"
+    {
+		struct cl2llvm_decl_list_t *decl_list = cl2llvm_decl_list_create();
+		decl_list->addr_qual = NULL;
+		(yyval.decl_list) = decl_list;
+	}
+    break;
+
+  case 22:
+
+/* Line 1806 of yacc.c  */
+#line 382 "parser.y"
+    {
+		struct cl2llvm_decl_list_t *decl_list = cl2llvm_decl_list_create();
+		decl_list->kernel_t = 	"kernel";
+		(yyval.decl_list) = decl_list;
+	}
+    break;
+
+  case 23:
+
+/* Line 1806 of yacc.c  */
+#line 388 "parser.y"
+    {
+		struct cl2llvm_decl_list_t *decl_list = cl2llvm_decl_list_create();
+		decl_list->inline_t = NULL;
+		(yyval.decl_list) = decl_list;
+	}
+    break;
+
+  case 24:
+
+/* Line 1806 of yacc.c  */
+#line 394 "parser.y"
+    {
+		struct cl2llvm_decl_list_t *decl_list = cl2llvm_decl_list_create();
+		decl_list->sc_spec = NULL;
+		(yyval.decl_list) = decl_list;
+
+	}
+    break;
+
+  case 25:
+
+/* Line 1806 of yacc.c  */
+#line 401 "parser.y"
+    {
+		struct cl2llvm_decl_list_t *decl_list = cl2llvm_decl_list_create();
+		decl_list->access_qual = NULL;
+		(yyval.decl_list) = decl_list;
+	}
+    break;
+
+  case 26:
+
+/* Line 1806 of yacc.c  */
+#line 407 "parser.y"
+    {
+		struct cl2llvm_decl_list_t *decl_list = cl2llvm_decl_list_create();
+		decl_list->type_qual = NULL;
+		(yyval.decl_list) = decl_list;
+	}
+    break;
+
+  case 36:
+
+/* Line 1806 of yacc.c  */
+#line 438 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 37:
+
+/* Line 1806 of yacc.c  */
+#line 443 "parser.y"
+    {
+		int i;
+		
+		struct cl2llvm_symbol_t *symbol = hash_table_get(current_function->symbol_table, (yyvsp[(1) - (2)].identifier));
+		if (symbol == NULL)	
+			yyerror("symbol undeclared first use in this program");
+		LLVMValueRef indices[100];
+		struct cl2llvm_val_t *current_index;
+		for(i = 0; i < list_count((yyvsp[(2) - (2)].list_val_t)); i++)
+		{
+			current_index = list_get((yyvsp[(2) - (2)].list_val_t), i);
+			indices[i] = current_index->val;
+		}
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+
+		LLVMValueRef array_ptr = LLVMBuildLoad(cl2llvm_builder, symbol->cl2llvm_val->val, temp_var_name);
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+
+		struct cl2llvm_val_t *deref_ptr = cl2llvm_val_create_w_init( LLVMBuildGEP( 
+			cl2llvm_builder, array_ptr, indices, list_count((yyvsp[(2) - (2)].list_val_t)), temp_var_name), 
+			symbol->cl2llvm_val->type->sign);
+		(yyval.llvm_value_ref) = deref_ptr;
+	}
+    break;
+
+  case 38:
+
+/* Line 1806 of yacc.c  */
+#line 469 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 39:
+
+/* Line 1806 of yacc.c  */
+#line 473 "parser.y"
+    {
+		struct cl2llvm_symbol_t *symbol;
+
+		symbol = hash_table_get(current_function->symbol_table, (yyvsp[(1) - (1)].identifier));
+		if (!symbol)
+			yyerror("undefined identifier");
+
+		struct cl2llvm_val_t *symbol_val_dup = cl2llvm_val_create_w_init(symbol->cl2llvm_val->val, symbol->cl2llvm_val->type->sign);
+
+		symbol_val_dup->type->llvm_type = symbol->cl2llvm_val->type->llvm_type;
+
+		(yyval.llvm_value_ref) = symbol_val_dup;
+	}
+    break;
+
+  case 40:
+
+/* Line 1806 of yacc.c  */
+#line 487 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 46:
+
+/* Line 1806 of yacc.c  */
+#line 503 "parser.y"
+    {
+		struct list_t *array_deref_list = list_create();
+		
+		if (LLVMGetTypeKind((yyvsp[(2) - (3)].llvm_value_ref)->type->llvm_type) != LLVMIntegerTypeKind)
+			yyerror("array index is not an integer");
+		list_add(array_deref_list, (yyvsp[(2) - (3)].llvm_value_ref));
+		(yyval.list_val_t) = array_deref_list;
+	}
+    break;
+
+  case 47:
+
+/* Line 1806 of yacc.c  */
+#line 512 "parser.y"
+    {
+		if (LLVMGetTypeKind((yyvsp[(3) - (4)].llvm_value_ref)->type->llvm_type) != LLVMIntegerTypeKind);
+			yyerror("array index is not an integer");
+		list_add((yyvsp[(1) - (4)].list_val_t), (yyvsp[(3) - (4)].llvm_value_ref));
+		(yyval.list_val_t) = (yyvsp[(1) - (4)].list_val_t);
+	}
+    break;
+
+  case 48:
+
+/* Line 1806 of yacc.c  */
+#line 522 "parser.y"
+    {
+		cl2llvm_val_free((yyvsp[(1) - (2)].llvm_value_ref));
+	}
+    break;
+
+  case 56:
+
+/* Line 1806 of yacc.c  */
+#line 533 "parser.y"
+    {
+		struct cl2llvm_val_t *ret_val;
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init( LLVMGetReturnType(current_function->func_type), current_function->sign);
+		if (type->llvm_type != (yyvsp[(2) - (3)].llvm_value_ref)->type->llvm_type || type->sign != (yyvsp[(2) - (3)].llvm_value_ref)->type->sign)
+			ret_val = llvm_type_cast((yyvsp[(2) - (3)].llvm_value_ref), type);
+		else
+			ret_val = (yyvsp[(2) - (3)].llvm_value_ref);
+		LLVMBuildRet(cl2llvm_builder, ret_val->val);
+		cl2llvm_type_free(type);
+		if (ret_val != (yyvsp[(2) - (3)].llvm_value_ref))
+			cl2llvm_val_free(ret_val);
+		cl2llvm_val_free((yyvsp[(2) - (3)].llvm_value_ref));
+	}
+    break;
+
+  case 62:
+
+/* Line 1806 of yacc.c  */
+#line 555 "parser.y"
+    {
+		printf("%s\n", (yyvsp[(1) - (4)].identifier));
+		struct cl2llvm_function_t *function = hash_table_get(cl2llvm_symbol_table, (yyvsp[(1) - (4)].identifier));
+		if (!function)
+			yyerror("undefined function");
+		LLVMTypeRef param_types[100];
+		LLVMGetParamTypes(function->func_type, param_types);
+		
+		LLVMValueRef cast_param_array[100];
+		int i;
+		/* check that parameter types match */
+		for (i = 0; i < function->arg_count; i++)
+		{
+			printf("loop\n");
+			struct cl2llvm_arg_t *current_func_arg = list_get(function->arg_list, i);
+			struct cl2llvm_val_t *current_param = list_get((yyvsp[(3) - (4)].list_val_t), i);
+			if (current_func_arg->type_spec->llvm_type != current_param->type->llvm_type || current_func_arg->type_spec->sign  != current_param->type->sign)
+			{
+				struct cl2llvm_type_t *type = cl2llvm_type_create_w_init( current_func_arg->type_spec->llvm_type, current_func_arg->type_spec->sign);
+				struct cl2llvm_val_t *cast_param = llvm_type_cast(current_param, type);
+				cl2llvm_type_free(type);
+				cast_param_array[i] = cast_param->val;
+				cl2llvm_val_free(current_param);
+				cl2llvm_val_free(cast_param);
+			}
+			else
+			{
+				cast_param_array[i] = current_param->val;
+				cl2llvm_val_free(current_param);
+			}
+		}
+		list_free((yyvsp[(3) - (4)].list_val_t));
+
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+
+		struct cl2llvm_val_t *ret_val = cl2llvm_val_create_w_init(
+			LLVMBuildCall(cl2llvm_builder, function->func,
+			cast_param_array, function->arg_count, temp_var_name),
+			function->sign);
+		
+		(yyval.llvm_value_ref) = ret_val;
+	}
+    break;
+
+  case 63:
+
+/* Line 1806 of yacc.c  */
+#line 599 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 64:
+
+/* Line 1806 of yacc.c  */
+#line 606 "parser.y"
+    {
+		struct list_t *param_list = list_create();
+		list_add(param_list, (yyvsp[(1) - (1)].llvm_value_ref));
+		(yyval.list_val_t) = param_list;
+	}
+    break;
+
+  case 65:
+
+/* Line 1806 of yacc.c  */
+#line 612 "parser.y"
+    {
+		(yyval.list_val_t) = NULL;
+	}
+    break;
+
+  case 66:
+
+/* Line 1806 of yacc.c  */
+#line 616 "parser.y"
+    {
+		(yyval.list_val_t) = NULL;
+	}
+    break;
+
+  case 67:
+
+/* Line 1806 of yacc.c  */
+#line 620 "parser.y"
+    {
+		list_add((yyvsp[(1) - (3)].list_val_t), (yyvsp[(3) - (3)].llvm_value_ref));
+		(yyval.list_val_t) = (yyvsp[(1) - (3)].list_val_t);
+	}
+    break;
+
+  case 68:
+
+/* Line 1806 of yacc.c  */
+#line 625 "parser.y"
+    {
+		(yyval.list_val_t) = NULL;
+	}
+    break;
+
+  case 69:
+
+/* Line 1806 of yacc.c  */
+#line 629 "parser.y"
+    {
+		(yyval.list_val_t) = NULL;
+	}
+    break;
+
+  case 71:
+
+/* Line 1806 of yacc.c  */
+#line 640 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 72:
+
+/* Line 1806 of yacc.c  */
+#line 644 "parser.y"
+    {
+		(yyval.llvm_value_ref) = (yyvsp[(2) - (2)].llvm_value_ref);
+	}
+    break;
+
+  case 73:
+
+/* Line 1806 of yacc.c  */
+#line 648 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 74:
+
+/* Line 1806 of yacc.c  */
+#line 655 "parser.y"
+    {
+		struct list_t *init_list = list_create();
+		struct cl2llvm_init_t *init = cl2llvm_init_create((yyvsp[(1) - (2)].identifier));
+
+		cl2llvm_val_free(init->cl2llvm_val);
+		init->cl2llvm_val = (yyvsp[(2) - (2)].llvm_value_ref);
+
+		list_add(init_list, init);
+		(yyval.init_list) = init_list;
+	}
+    break;
+
+  case 75:
+
+/* Line 1806 of yacc.c  */
+#line 666 "parser.y"
+    {
+		struct cl2llvm_init_t *init = cl2llvm_init_create((yyvsp[(3) - (4)].identifier));
+
+		cl2llvm_val_free(init->cl2llvm_val);
+		init->cl2llvm_val = (yyvsp[(4) - (4)].llvm_value_ref);
+
+		list_add((yyvsp[(1) - (4)].init_list), init);
+		(yyval.init_list) = (yyvsp[(1) - (4)].init_list);
+	}
+    break;
+
+  case 76:
+
+/* Line 1806 of yacc.c  */
+#line 676 "parser.y"
+    {
+		struct list_t *init_list = list_create();
+		struct cl2llvm_init_t *init = cl2llvm_init_create((yyvsp[(1) - (3)].identifier));
+
+		cl2llvm_val_free(init->cl2llvm_val);
+		init->cl2llvm_val = (yyvsp[(3) - (3)].llvm_value_ref);
+		init->array_deref_list = (yyvsp[(2) - (3)].list_val_t);
+
+		list_add(init_list, init);
+		(yyval.init_list) = init_list;
+
+	}
+    break;
+
+  case 77:
+
+/* Line 1806 of yacc.c  */
+#line 689 "parser.y"
+    {
+		struct cl2llvm_init_t *init = cl2llvm_init_create((yyvsp[(3) - (5)].identifier));
+
+		cl2llvm_val_free(init->cl2llvm_val);
+		init->cl2llvm_val = (yyvsp[(5) - (5)].llvm_value_ref);
+		init->array_deref_list = (yyvsp[(4) - (5)].list_val_t);
+
+		list_add((yyvsp[(1) - (5)].init_list), init);
+		(yyval.init_list) = (yyvsp[(1) - (5)].init_list);
+	}
+    break;
+
+  case 78:
+
+/* Line 1806 of yacc.c  */
+#line 704 "parser.y"
+    {
+		struct cl2llvm_symbol_t *symbol;
+		struct cl2llvm_val_t *cast_to_val;
+		int init_count = list_count((yyvsp[(2) - (3)].init_list));
+		int i;
+		for(i = 0; i < init_count; i++)
+		{	
+			int err;			
+			struct cl2llvm_init_t *current_list_elem = list_get((yyvsp[(2) - (3)].init_list), i);
+			if (current_list_elem->array_deref_list == NULL)
+			{
+				symbol = cl2llvm_symbol_create_w_init( LLVMBuildAlloca( 
+					cl2llvm_builder, (yyvsp[(1) - (3)].decl_list)->type_spec->llvm_type, 
+					current_list_elem->name), (yyvsp[(1) - (3)].decl_list)->type_spec->sign, 
+					current_list_elem->name);
+					symbol->cl2llvm_val->type->llvm_type = (yyvsp[(1) - (3)].decl_list)->type_spec->llvm_type;
+				err = hash_table_insert(current_function->symbol_table, 
+					current_list_elem->name, symbol);
+				if (!err)
+					printf("duplicated symbol");
+				if (LLVMTypeOf(current_list_elem->cl2llvm_val->val) == (yyvsp[(1) - (3)].decl_list)->type_spec->llvm_type 
+					&& current_list_elem->cl2llvm_val->type->sign == (yyvsp[(1) - (3)].decl_list)->type_spec->sign)
+				{
+					LLVMBuildStore(cl2llvm_builder,
+						current_list_elem->cl2llvm_val->val, symbol->cl2llvm_val->val);
+				}
+				else
+				{
+					cast_to_val = llvm_type_cast( current_list_elem->cl2llvm_val, (yyvsp[(1) - (3)].decl_list)->type_spec);
+					LLVMBuildStore(cl2llvm_builder,
+						cast_to_val->val,
+						symbol->cl2llvm_val->val);
+					cl2llvm_val_free(cast_to_val);
+				}
+			}
+			else
+			{	
+				struct cl2llvm_val_t *array_length = list_get(current_list_elem->array_deref_list, 0);
+				symbol = cl2llvm_symbol_create_w_init( 
+					LLVMBuildArrayAlloca( cl2llvm_builder, 
+					(yyvsp[(1) - (3)].decl_list)->type_spec->llvm_type, array_length->val, 
+					current_list_elem->name) , (yyvsp[(1) - (3)].decl_list)->type_spec->sign, 
+					current_list_elem->name);
+				symbol->cl2llvm_val->type->llvm_type = (yyvsp[(1) - (3)].decl_list)->type_spec->llvm_type;
+				err = hash_table_insert(current_function->symbol_table, 
+					current_list_elem->name, symbol);
+				if (!err)
+					printf("duplicated symbol");
+
+			}
+		}
+		cl2llvm_decl_list_free((yyvsp[(1) - (3)].decl_list));
+		LIST_FOR_EACH((yyvsp[(2) - (3)].init_list), i)
+		{
+			cl2llvm_init_free(list_get((yyvsp[(2) - (3)].init_list), i));
+		}
+		list_free((yyvsp[(2) - (3)].init_list));
+	}
+    break;
+
+  case 90:
+
+/* Line 1806 of yacc.c  */
+#line 798 "parser.y"
+    {
+		/* goto endif block*/
+		LLVMBuildBr(cl2llvm_builder, (yyvsp[(1) - (1)].basic_block_ref));
+		LLVMPositionBuilderAtEnd(cl2llvm_builder, (yyvsp[(1) - (1)].basic_block_ref));
+	}
+    break;
+
+  case 91:
+
+/* Line 1806 of yacc.c  */
+#line 804 "parser.y"
+    { 
+		/*create endif block. $1 now becomes the if false block*/
+		snprintf(block_name, sizeof block_name,
+			"block_%d", block_count++);
+		LLVMBasicBlockRef endif = LLVMAppendBasicBlock(current_function->func, block_name);
+		
+		/*Branch to endif*/
+		LLVMBuildBr(cl2llvm_builder, endif);
+		/*position builder at if false block*/
+		LLVMPositionBuilderAtEnd(cl2llvm_builder, (yyvsp[(1) - (2)].basic_block_ref));
+		(yyval.basic_block_ref) = endif;
+	}
+    break;
+
+  case 92:
+
+/* Line 1806 of yacc.c  */
+#line 817 "parser.y"
+    {
+		/*branch to endif block and prepare to write code for endif block*/
+		LLVMBuildBr(cl2llvm_builder, (yyvsp[(3) - (4)].basic_block_ref));
+		LLVMPositionBuilderAtEnd(cl2llvm_builder, (yyvsp[(3) - (4)].basic_block_ref));
+
+	}
+    break;
+
+  case 93:
+
+/* Line 1806 of yacc.c  */
+#line 827 "parser.y"
+    {
+		struct cl2llvm_type_t *i1 = cl2llvm_type_create_w_init(LLVMInt1Type(), 1);
+		
+		/*Create endif block*/
+		snprintf(block_name, sizeof block_name,
+			"block_%d", block_count++);
+		LLVMBasicBlockRef endif = LLVMAppendBasicBlock(current_function->func, block_name);
+		
+		/*Create if true block*/
+		snprintf(block_name, sizeof block_name,
+			"block_%d", block_count++);
+		LLVMBasicBlockRef if_true = LLVMAppendBasicBlock(current_function->func, block_name);
+		
+		/*evaluate expression*/
+		struct cl2llvm_val_t *bool_val =  llvm_type_cast((yyvsp[(3) - (4)].llvm_value_ref), i1);
+		LLVMBuildCondBr(cl2llvm_builder, bool_val->val, if_true, endif);
+		(yyval.basic_block_ref) = endif;
+		
+		/*prepare to write if_true block*/
+		LLVMPositionBuilderAtEnd(cl2llvm_builder, if_true);
+	
+		cl2llvm_val_free(bool_val);
+		cl2llvm_val_free((yyvsp[(3) - (4)].llvm_value_ref));
+		cl2llvm_type_free(i1);
+	}
+    break;
+
+  case 94:
+
+/* Line 1806 of yacc.c  */
+#line 853 "parser.y"
+    {
+		(yyval.basic_block_ref) = (yyvsp[(5) - (6)].basic_block_ref);
+	}
+    break;
+
+  case 99:
+
+/* Line 1806 of yacc.c  */
+#line 873 "parser.y"
+    {
+		struct cl2llvm_type_t *i1 = cl2llvm_type_create_w_init(LLVMInt1Type(), 1);
+
+		snprintf(block_name, sizeof block_name,
+			"block_%d", block_count++);
+		LLVMBasicBlockRef if_false = LLVMAppendBasicBlock(current_function->func, block_name);
+		
+		struct cl2llvm_val_t *bool_val =  llvm_type_cast((yyvsp[(4) - (5)].llvm_value_ref), i1);
+		LLVMBuildCondBr(cl2llvm_builder, bool_val->val, (yyvsp[(2) - (5)].basic_block_ref), if_false);
+		(yyval.basic_block_ref) = if_false;
+		LLVMPositionBuilderAtEnd(cl2llvm_builder, (yyvsp[(2) - (5)].basic_block_ref));
+	
+		cl2llvm_val_free(bool_val);
+		cl2llvm_type_free(i1);
+	}
+    break;
+
+  case 100:
+
+/* Line 1806 of yacc.c  */
+#line 889 "parser.y"
+    {
+		struct cl2llvm_type_t *i1 = cl2llvm_type_create_w_init(LLVMInt1Type(), 1);
+		struct cl2llvm_val_t *bool_val =  llvm_type_cast((yyvsp[(4) - (7)].llvm_value_ref), i1);
+		LLVMBuildCondBr(cl2llvm_builder, bool_val->val, (yyvsp[(2) - (7)].basic_block_ref), (yyvsp[(6) - (7)].basic_block_ref));
+		LLVMPositionBuilderAtEnd(cl2llvm_builder, (yyvsp[(6) - (7)].basic_block_ref));
+		cl2llvm_val_free(bool_val);
+		cl2llvm_val_free((yyvsp[(4) - (7)].llvm_value_ref));
+		cl2llvm_type_free(i1);
+	}
+    break;
+
+  case 101:
+
+/* Line 1806 of yacc.c  */
+#line 902 "parser.y"
+    {
+		snprintf(block_name, sizeof block_name,
+			"block_%d", block_count++);
+		LLVMBasicBlockRef while_loop = LLVMAppendBasicBlock(current_function->func, block_name);
+		(yyval.basic_block_ref) = while_loop;
+	}
+    break;
+
+  case 102:
+
+/* Line 1806 of yacc.c  */
+#line 912 "parser.y"
+    {
+		/*create object so that maybe_expr always points to a memory 
+		  location regardless of its contents*/
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 105:
+
+/* Line 1806 of yacc.c  */
+#line 924 "parser.y"
+    {
+		(yyval.llvm_value_ref) = (yyvsp[(2) - (3)].llvm_value_ref);
+	}
+    break;
+
+  case 106:
+
+/* Line 1806 of yacc.c  */
+#line 929 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create();
+		struct cl2llvm_val_t *op1, *op2;
+		
+		type_unify((yyvsp[(1) - (3)].llvm_value_ref), (yyvsp[(3) - (3)].llvm_value_ref), &op1, &op2);
+		if(op1 == (yyvsp[(1) - (3)].llvm_value_ref))
+		{
+			type->llvm_type = op1->type->llvm_type;
+			type->sign = op1->type->sign;
+		}
+		else
+		{
+			type->llvm_type = op2->type->llvm_type;
+			type->sign = op2->type->sign;
+		}
+		snprintf(temp_var_name, sizeof temp_var_name,
+				"tmp%d", temp_var_count++);
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+
+			value->val = LLVMBuildAdd(cl2llvm_builder, op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+
+			value->val = LLVMBuildFAdd(cl2llvm_builder, op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+
+			yyerror("invalid type of operands for addition");
+		}
+		if ((yyvsp[(1) - (3)].llvm_value_ref) != op1)
+			cl2llvm_val_free(op1);
+		else if ((yyvsp[(3) - (3)].llvm_value_ref) != op2)
+			cl2llvm_val_free( op2);
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 107:
+
+/* Line 1806 of yacc.c  */
+#line 979 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create();
+		struct cl2llvm_val_t *op1, *op2;
+		
+		type_unify((yyvsp[(1) - (3)].llvm_value_ref), (yyvsp[(3) - (3)].llvm_value_ref), &op1, & op2);
+		if(op1 == (yyvsp[(1) - (3)].llvm_value_ref))
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+		else
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+	
+		snprintf(temp_var_name, sizeof temp_var_name,
+				"tmp%d", temp_var_count++);
+
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+
+			value->val = LLVMBuildSub(cl2llvm_builder, op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+
+			value->val = LLVMBuildFSub(cl2llvm_builder, op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+
+			yyerror("invalid type of operands for addition");
+		}
+		if ((yyvsp[(1) - (3)].llvm_value_ref) != op1)
+			cl2llvm_val_free(op1);
+		else if ((yyvsp[(3) - (3)].llvm_value_ref) != op2)
+			cl2llvm_val_free(op2);
+
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 108:
+
+/* Line 1806 of yacc.c  */
+#line 1032 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create();
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+
+		struct cl2llvm_val_t *op1, *op2;
+		
+		type_unify((yyvsp[(1) - (3)].llvm_value_ref), (yyvsp[(3) - (3)].llvm_value_ref), &op1, &op2);
+		if(op1 == (yyvsp[(1) - (3)].llvm_value_ref))
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+		else
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+		
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+			value->val = LLVMBuildMul(cl2llvm_builder, op1->val,
+				op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+			value->val = LLVMBuildFMul(cl2llvm_builder, op1->val,
+				op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+		default:
+
+			yyerror("invalid type of operands for addition");
+		}
+		if ((yyvsp[(1) - (3)].llvm_value_ref) != op1)
+			cl2llvm_val_free(op1);
+		else if ((yyvsp[(3) - (3)].llvm_value_ref) != op2)
+			cl2llvm_val_free(op2);
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_type_free(type);
+
+		(yyval.llvm_value_ref) = value;
+
+	}
+    break;
+
+  case 109:
+
+/* Line 1806 of yacc.c  */
+#line 1085 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create();
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+
+		struct cl2llvm_val_t *op1, *op2;
+		
+		type_unify((yyvsp[(1) - (3)].llvm_value_ref), (yyvsp[(3) - (3)].llvm_value_ref), &op1, & op2);
+		if(op1 == (yyvsp[(1) - (3)].llvm_value_ref))
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+		else
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+
+
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+			if (type->sign)
+			{
+				value->val = LLVMBuildSDiv(cl2llvm_builder, 
+					op1->val, op2->val, temp_var_name);
+			}
+			else
+			{
+				value->val = LLVMBuildUDiv(cl2llvm_builder, 
+					op1->val, op2->val, temp_var_name);
+			}
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+			value->val = LLVMBuildFDiv(cl2llvm_builder, 
+					op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+			
+			yyerror("invalid type of operands for addition");
+		}
+		if ((yyvsp[(1) - (3)].llvm_value_ref) != op1)
+			cl2llvm_val_free(op1);
+		else if ((yyvsp[(3) - (3)].llvm_value_ref) != op2)
+			cl2llvm_val_free(op2);
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 110:
+
+/* Line 1806 of yacc.c  */
+#line 1146 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create();
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+
+		struct cl2llvm_val_t *op1, *op2;
+		
+		type_unify((yyvsp[(1) - (3)].llvm_value_ref), (yyvsp[(3) - (3)].llvm_value_ref), &op1, & op2);
+		if(op1 == (yyvsp[(1) - (3)].llvm_value_ref))
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+		else
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+
+		switch (type->sign)
+		{
+		case 1:
+			value->val = LLVMBuildSRem(cl2llvm_builder, 
+				op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case 0:
+			value->val = LLVMBuildURem(cl2llvm_builder, 
+				op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+			
+			yyerror("invalid type of operands for addition");
+		}
+		if ((yyvsp[(1) - (3)].llvm_value_ref) != op1)
+			cl2llvm_val_free(op1);
+		else if ((yyvsp[(3) - (3)].llvm_value_ref) != op2)
+			cl2llvm_val_free(op2);
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+
+	}
+    break;
+
+  case 113:
+
+/* Line 1806 of yacc.c  */
+#line 1199 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create();
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+
+		struct cl2llvm_val_t *op1, *op2;
+		
+		type_unify((yyvsp[(1) - (3)].llvm_value_ref), (yyvsp[(3) - (3)].llvm_value_ref), &op1, & op2);
+		if(op1 == (yyvsp[(1) - (3)].llvm_value_ref))
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+		else
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+
+			value->val = LLVMBuildICmp(cl2llvm_builder, LLVMIntEQ,
+				op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+
+			value->val = LLVMBuildFCmp(cl2llvm_builder,
+				LLVMRealOEQ, op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+
+			yyerror("invalid type of operands for equality");
+		}
+		if ((yyvsp[(1) - (3)].llvm_value_ref) != op1)
+			cl2llvm_val_free(op1);
+		else if ((yyvsp[(3) - (3)].llvm_value_ref) != op2)
+			cl2llvm_val_free(op2);
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 114:
+
+/* Line 1806 of yacc.c  */
+#line 1253 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create();
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+
+		struct cl2llvm_val_t *op1, *op2;
+		
+		type_unify((yyvsp[(1) - (3)].llvm_value_ref), (yyvsp[(3) - (3)].llvm_value_ref), &op1, & op2);
+		if(op1 == (yyvsp[(1) - (3)].llvm_value_ref))
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+		else
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+
+			value->val = LLVMBuildICmp(cl2llvm_builder, LLVMIntNE,
+				op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+
+			value->val = LLVMBuildFCmp(cl2llvm_builder, 
+				LLVMRealONE, op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+
+			yyerror("invalid type of operands for addition");
+		}
+		if ((yyvsp[(1) - (3)].llvm_value_ref) != op1)
+			cl2llvm_val_free(op1);
+		else if ((yyvsp[(3) - (3)].llvm_value_ref) != op2)
+			cl2llvm_val_free(op2);
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+
+	}
+    break;
+
+  case 115:
+
+/* Line 1806 of yacc.c  */
+#line 1308 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create();
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+
+		struct cl2llvm_val_t *op1, *op2;
+		
+		type_unify((yyvsp[(1) - (3)].llvm_value_ref), (yyvsp[(3) - (3)].llvm_value_ref), &op1, & op2);
+		if(op1 == (yyvsp[(1) - (3)].llvm_value_ref))
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+		else
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+
+			if (type->sign)
+			{
+				value->val = LLVMBuildICmp(cl2llvm_builder, 
+					LLVMIntSLT, op1->val, op2->val, 
+					temp_var_name);
+			}
+			else
+			{
+				value->val = LLVMBuildICmp(cl2llvm_builder, 
+					LLVMIntULT, op1->val, op2->val, 
+					temp_var_name);
+			}
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+
+			value->val = LLVMBuildFCmp(cl2llvm_builder, 
+				LLVMRealOLT, op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+
+			yyerror("invalid type of operands for addition");
+		}
+		if ((yyvsp[(1) - (3)].llvm_value_ref) != op1)
+			cl2llvm_val_free(op1);
+		else if ((yyvsp[(3) - (3)].llvm_value_ref) != op2)
+			cl2llvm_val_free(op2);
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+
+	}
+    break;
+
+  case 116:
+
+/* Line 1806 of yacc.c  */
+#line 1373 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create();
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+
+		struct cl2llvm_val_t *op1, *op2;
+		
+		type_unify((yyvsp[(1) - (3)].llvm_value_ref), (yyvsp[(3) - (3)].llvm_value_ref), &op1, & op2);
+		if(op1 == (yyvsp[(1) - (3)].llvm_value_ref))
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+		else
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+
+			if (type->sign)
+			{
+				value->val = LLVMBuildICmp(cl2llvm_builder, 
+					LLVMIntSGT, op1->val, op2->val, 
+					temp_var_name);
+			}
+			else
+			{
+				value->val = LLVMBuildICmp(cl2llvm_builder, 
+					LLVMIntUGT, op1->val, op2->val, 
+					temp_var_name);
+			}
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+
+			value->val = LLVMBuildFCmp(cl2llvm_builder, 
+				LLVMRealOGT, op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+
+			yyerror("invalid type of operands for addition");
+		}
+		if ((yyvsp[(1) - (3)].llvm_value_ref) != op1)
+			cl2llvm_val_free(op1);
+		else if ((yyvsp[(3) - (3)].llvm_value_ref) != op2)
+			cl2llvm_val_free(op2);
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 117:
+
+/* Line 1806 of yacc.c  */
+#line 1437 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create();
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+
+		struct cl2llvm_val_t *op1, *op2;
+		
+		type_unify((yyvsp[(1) - (3)].llvm_value_ref), (yyvsp[(3) - (3)].llvm_value_ref), &op1, & op2);
+		if(op1 == (yyvsp[(1) - (3)].llvm_value_ref))
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+		else
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+
+			if (type->sign)
+			{
+				value->val = LLVMBuildICmp(cl2llvm_builder, 
+					LLVMIntSLE, op1->val, op2->val, 
+					temp_var_name);
+			}
+			else
+			{
+				value->val = LLVMBuildICmp(cl2llvm_builder, 
+					LLVMIntULE, op1->val, op2->val, 
+					temp_var_name);
+			}
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+
+			value->val = LLVMBuildFCmp(cl2llvm_builder, 
+				LLVMRealOLE, op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+
+			yyerror("invalid type of operands for addition");
+		}
+		if ((yyvsp[(1) - (3)].llvm_value_ref) != op1)
+			cl2llvm_val_free(op1);
+		else if ((yyvsp[(3) - (3)].llvm_value_ref) != op2)
+			cl2llvm_val_free(op2);
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 118:
+
+/* Line 1806 of yacc.c  */
+#line 1501 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create();
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+
+		struct cl2llvm_val_t *op1, *op2;
+		
+		type_unify((yyvsp[(1) - (3)].llvm_value_ref), (yyvsp[(3) - (3)].llvm_value_ref), &op1, & op2);
+		if(op1 == (yyvsp[(1) - (3)].llvm_value_ref))
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+		else
+		{
+			type->llvm_type = LLVMTypeOf(op1->val);
+			type->sign = op1->type->sign;
+		}
+
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+
+			if (type->sign)
+			{
+				value->val = LLVMBuildICmp(cl2llvm_builder, 
+					LLVMIntSGE, op1->val, op2->val, 
+					temp_var_name);
+			}
+			else
+			{
+				value->val = LLVMBuildICmp(cl2llvm_builder, 
+					LLVMIntUGE, op1->val, op2->val, 
+					temp_var_name);
+			}
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+
+			value->val = LLVMBuildFCmp(cl2llvm_builder, 
+				LLVMRealOGE, op1->val, op2->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+
+			yyerror("invalid type of operands for addition");
+		}
+		if ((yyvsp[(1) - (3)].llvm_value_ref) != op1)
+			cl2llvm_val_free(op1);
+		else if ((yyvsp[(3) - (3)].llvm_value_ref) != op2)
+			cl2llvm_val_free(op2);
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 121:
+
+/* Line 1806 of yacc.c  */
+#line 1567 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init( 
+			(yyvsp[(1) - (3)].llvm_value_ref)->type->llvm_type , (yyvsp[(1) - (3)].llvm_value_ref)->type->sign);
+
+		struct cl2llvm_val_t *value = llvm_type_cast((yyvsp[(3) - (3)].llvm_value_ref), type);
+		LLVMBuildStore(cl2llvm_builder, (yyvsp[(3) - (3)].llvm_value_ref)->val, (yyvsp[(1) - (3)].llvm_value_ref)->val);
+		cl2llvm_type_free(type);
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 122:
+
+/* Line 1806 of yacc.c  */
+#line 1579 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init( 
+			(yyvsp[(1) - (3)].llvm_value_ref)->type->llvm_type , (yyvsp[(1) - (3)].llvm_value_ref)->type->sign);
+		struct cl2llvm_val_t *value;
+		
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+		struct cl2llvm_val_t *lval = cl2llvm_val_create_w_init(
+			LLVMBuildLoad(cl2llvm_builder, (yyvsp[(1) - (3)].llvm_value_ref)->val, temp_var_name),
+			(yyvsp[(1) - (3)].llvm_value_ref)->type->sign);
+
+		struct cl2llvm_val_t *rval = llvm_type_cast((yyvsp[(3) - (3)].llvm_value_ref), type);
+	
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+		
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+
+			value = cl2llvm_val_create_w_init(
+				LLVMBuildAdd(cl2llvm_builder, lval->val, 
+				rval->val, temp_var_name), type->sign);
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+
+			value = cl2llvm_val_create_w_init(
+				LLVMBuildFAdd(cl2llvm_builder, lval->val, 
+				rval->val, temp_var_name), type->sign);
+			break;
+
+		default:
+
+			yyerror("invalid type of operands for addition");
+			value = cl2llvm_val_create();
+		}
+
+		LLVMBuildStore(cl2llvm_builder, value->val, (yyvsp[(1) - (3)].llvm_value_ref)->val);
+		
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_val_free(rval);
+		cl2llvm_val_free(lval);
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 123:
+
+/* Line 1806 of yacc.c  */
+#line 1629 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init( 
+			(yyvsp[(1) - (3)].llvm_value_ref)->type->llvm_type , (yyvsp[(1) - (3)].llvm_value_ref)->type->sign);
+		struct cl2llvm_val_t *value;
+		
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+		struct cl2llvm_val_t *lval = cl2llvm_val_create_w_init(
+			LLVMBuildLoad(cl2llvm_builder, (yyvsp[(1) - (3)].llvm_value_ref)->val, temp_var_name),
+			(yyvsp[(1) - (3)].llvm_value_ref)->type->sign);
+
+		struct cl2llvm_val_t *rval = llvm_type_cast((yyvsp[(3) - (3)].llvm_value_ref), type);
+
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+		
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+
+			value = cl2llvm_val_create_w_init(
+				LLVMBuildSub(cl2llvm_builder, lval->val, 
+				rval->val, temp_var_name), type->sign);
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+
+			value = cl2llvm_val_create_w_init(
+				LLVMBuildFSub(cl2llvm_builder, lval->val, 
+				rval->val, temp_var_name), type->sign);
+			break;
+
+		default:
+			
+			yyerror("invalid type of operands for addition");
+			value = cl2llvm_val_create();
+		}
+
+		LLVMBuildStore(cl2llvm_builder, value->val, (yyvsp[(1) - (3)].llvm_value_ref)->val);
+
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_val_free(rval);
+		cl2llvm_val_free(lval);
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 124:
+
+/* Line 1806 of yacc.c  */
+#line 1679 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init( 
+			(yyvsp[(1) - (3)].llvm_value_ref)->type->llvm_type , (yyvsp[(1) - (3)].llvm_value_ref)->type->sign);
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+		struct cl2llvm_val_t *lval = cl2llvm_val_create_w_init(
+			LLVMBuildLoad(cl2llvm_builder, (yyvsp[(1) - (3)].llvm_value_ref)->val, temp_var_name),
+			(yyvsp[(1) - (3)].llvm_value_ref)->type->sign);
+	
+		struct cl2llvm_val_t *rval = llvm_type_cast((yyvsp[(3) - (3)].llvm_value_ref), type);
+
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+		
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+			if (type->sign)
+			{
+				value->val = LLVMBuildSDiv(cl2llvm_builder, 
+					lval->val, rval->val, temp_var_name);
+			}
+			else
+			{
+				value->val = LLVMBuildUDiv(cl2llvm_builder, 
+					lval->val, rval->val, temp_var_name);
+			}
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+			value->val = LLVMBuildFDiv(cl2llvm_builder, 
+					lval->val, rval->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+			
+			yyerror("invalid type of operands for addition");
+		}
+	
+		LLVMBuildStore(cl2llvm_builder, value->val, (yyvsp[(1) - (3)].llvm_value_ref)->val);
+		
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_val_free(rval);
+		cl2llvm_val_free(lval);
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 125:
+
+/* Line 1806 of yacc.c  */
+#line 1736 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init( 
+			(yyvsp[(1) - (3)].llvm_value_ref)->type->llvm_type , (yyvsp[(1) - (3)].llvm_value_ref)->type->sign);
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+		struct cl2llvm_val_t *lval = cl2llvm_val_create_w_init(
+			LLVMBuildLoad(cl2llvm_builder, (yyvsp[(1) - (3)].llvm_value_ref)->val, temp_var_name),
+			(yyvsp[(1) - (3)].llvm_value_ref)->type->sign);
+	
+		struct cl2llvm_val_t *rval = llvm_type_cast((yyvsp[(3) - (3)].llvm_value_ref), type);
+
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+		
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+
+			value->val = LLVMBuildMul(cl2llvm_builder, 
+				lval->val, rval->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		case LLVMHalfTypeKind:
+		case LLVMFloatTypeKind:
+		case LLVMDoubleTypeKind:
+			value->val = LLVMBuildFMul(cl2llvm_builder, 
+					lval->val, rval->val, temp_var_name);
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+			
+			yyerror("invalid type of operands for addition");
+		}
+	
+		LLVMBuildStore(cl2llvm_builder, value->val, (yyvsp[(1) - (3)].llvm_value_ref)->val);
+	
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_val_free(lval);
+		cl2llvm_val_free(rval);
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 126:
+
+/* Line 1806 of yacc.c  */
+#line 1786 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init( 
+			(yyvsp[(1) - (3)].llvm_value_ref)->type->llvm_type , (yyvsp[(1) - (3)].llvm_value_ref)->type->sign);
+		struct cl2llvm_val_t *value = cl2llvm_val_create();
+		
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+		struct cl2llvm_val_t *lval = cl2llvm_val_create_w_init(
+			LLVMBuildLoad(cl2llvm_builder, (yyvsp[(1) - (3)].llvm_value_ref)->val, temp_var_name),
+			(yyvsp[(1) - (3)].llvm_value_ref)->type->sign);
+	
+		struct cl2llvm_val_t *rval = llvm_type_cast((yyvsp[(3) - (3)].llvm_value_ref), type);
+
+		snprintf(temp_var_name, sizeof temp_var_name,
+			"tmp%d", temp_var_count++);
+		
+		switch (LLVMGetTypeKind(type->llvm_type))
+		{
+		case LLVMIntegerTypeKind:
+			if (type->sign)
+			{
+				value->val = LLVMBuildSRem(cl2llvm_builder, 
+					lval->val, rval->val, temp_var_name);
+			}
+			else
+			{
+				value->val = LLVMBuildURem(cl2llvm_builder, 
+					lval->val, rval->val, temp_var_name);
+			}
+			value->type->sign = type->sign;
+			value->type->llvm_type = type->llvm_type;
+			break;
+
+		default:
+			
+			yyerror("invalid type of operands for addition");
+		}
+	
+		LLVMBuildStore(cl2llvm_builder, value->val, (yyvsp[(1) - (3)].llvm_value_ref)->val);
+		
+		cl2llvm_val_free((yyvsp[(1) - (3)].llvm_value_ref));
+		cl2llvm_val_free((yyvsp[(3) - (3)].llvm_value_ref));
+		cl2llvm_val_free(rval);
+		cl2llvm_val_free(lval);
+		cl2llvm_type_free(type);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 133:
+
+/* Line 1806 of yacc.c  */
+#line 1841 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 134:
+
+/* Line 1806 of yacc.c  */
+#line 1846 "parser.y"
+    {
+		(yyval.llvm_value_ref) = (yyvsp[(1) - (1)].llvm_value_ref);
+	}
+    break;
+
+  case 135:
+
+/* Line 1806 of yacc.c  */
+#line 1851 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 139:
+
+/* Line 1806 of yacc.c  */
+#line 1863 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 140:
+
+/* Line 1806 of yacc.c  */
+#line 1867 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 141:
+
+/* Line 1806 of yacc.c  */
+#line 1871 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 142:
+
+/* Line 1806 of yacc.c  */
+#line 1875 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 143:
+
+/* Line 1806 of yacc.c  */
+#line 1879 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 144:
+
+/* Line 1806 of yacc.c  */
+#line 1883 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 145:
+
+/* Line 1806 of yacc.c  */
+#line 1887 "parser.y"
+    {
+		printf("cast rule\n");
+		llvm_type_cast((yyvsp[(4) - (4)].llvm_value_ref), (yyvsp[(2) - (4)].llvm_type_ref));
+		(yyval.llvm_value_ref) = (yyvsp[(4) - (4)].llvm_value_ref);
+	}
+    break;
+
+  case 146:
+
+/* Line 1806 of yacc.c  */
+#line 1893 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 147:
+
+/* Line 1806 of yacc.c  */
+#line 1897 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 148:
+
+/* Line 1806 of yacc.c  */
+#line 1901 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 156:
+
+/* Line 1806 of yacc.c  */
+#line 1932 "parser.y"
+    {
+		struct cl2llvm_val_t *value = cl2llvm_val_create_w_init(
+			LLVMConstInt(LLVMInt32Type(), (yyvsp[(1) - (1)].const_int_val), 0), 1);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 157:
+
+/* Line 1806 of yacc.c  */
+#line 1938 "parser.y"
+    {
+		struct cl2llvm_val_t *value = cl2llvm_val_create_w_init(
+			LLVMConstInt(LLVMInt32Type(), (yyvsp[(1) - (1)].const_int_val), 0), 1);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 158:
+
+/* Line 1806 of yacc.c  */
+#line 1944 "parser.y"
+    {
+		struct cl2llvm_val_t *value = cl2llvm_val_create_w_init(
+			LLVMConstInt(LLVMInt32Type(), (yyvsp[(1) - (1)].const_int_val), 0), 0);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 159:
+
+/* Line 1806 of yacc.c  */
+#line 1950 "parser.y"
+    {
+		struct cl2llvm_val_t *value =  cl2llvm_val_create_w_init(
+			LLVMConstInt(LLVMInt32Type(), (yyvsp[(1) - (1)].const_int_val), 0), 0);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 160:
+
+/* Line 1806 of yacc.c  */
+#line 1956 "parser.y"
+    {
+		struct cl2llvm_val_t *value = cl2llvm_val_create_w_init(
+			LLVMConstInt(LLVMInt64Type(), (yyvsp[(1) - (1)].const_int_val_ull), 0), 1);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 161:
+
+/* Line 1806 of yacc.c  */
+#line 1962 "parser.y"
+    {
+		struct cl2llvm_val_t *value = cl2llvm_val_create_w_init(
+			LLVMConstInt(LLVMInt64Type(), (yyvsp[(1) - (1)].const_int_val_ull), 0), 0);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 162:
+
+/* Line 1806 of yacc.c  */
+#line 1968 "parser.y"
+    {
+		struct cl2llvm_val_t *value = cl2llvm_val_create_w_init(
+			LLVMConstReal(LLVMFloatType(), (yyvsp[(1) - (1)].const_float_val)), 1);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 163:
+
+/* Line 1806 of yacc.c  */
+#line 1974 "parser.y"
+    {
+		struct cl2llvm_val_t *value = cl2llvm_val_create_w_init(
+			LLVMConstReal(LLVMHalfType(), (yyvsp[(1) - (1)].const_float_val)), 1);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 164:
+
+/* Line 1806 of yacc.c  */
+#line 1980 "parser.y"
+    {
+		struct cl2llvm_val_t *value = cl2llvm_val_create_w_init(
+			LLVMConstReal(LLVMFloatType(), (yyvsp[(1) - (1)].const_float_val)), 1);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 165:
+
+/* Line 1806 of yacc.c  */
+#line 1986 "parser.y"
+    {
+		struct cl2llvm_val_t *value = cl2llvm_val_create_w_init(
+			LLVMConstReal(LLVMDoubleType(), (yyvsp[(1) - (1)].const_float_val)), 1);
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 166:
+
+/* Line 1806 of yacc.c  */
+#line 1992 "parser.y"
+    {
+		snprintf(temp_var_name, sizeof(temp_var_name),
+				"tmp%d", temp_var_count++);
+		struct cl2llvm_val_t *value = cl2llvm_val_create_w_init(
+			LLVMBuildLoad(cl2llvm_builder, (yyvsp[(1) - (1)].llvm_value_ref)->val, temp_var_name),
+			(yyvsp[(1) - (1)].llvm_value_ref)->type->sign);
+		if (LLVMGetTypeKind(value->type->llvm_type) == LLVMArrayTypeKind
+			|| LLVMGetTypeKind(value->type->llvm_type) == LLVMPointerTypeKind
+			|| LLVMGetTypeKind(value->type->llvm_type) == LLVMStructTypeKind)
+		{
+			value->type->llvm_type = LLVMGetElementType(value->type->llvm_type);
+		}
+		cl2llvm_val_free((yyvsp[(1) - (1)].llvm_value_ref));
+
+		(yyval.llvm_value_ref) = value;
+	}
+    break;
+
+  case 167:
+
+/* Line 1806 of yacc.c  */
+#line 2010 "parser.y"
+    {
+		(yyval.llvm_value_ref) = NULL;
+	}
+    break;
+
+  case 168:
+
+/* Line 1806 of yacc.c  */
+#line 2018 "parser.y"
+    {
+		(yyval.llvm_type_ref) = (yyvsp[(1) - (1)].llvm_type_ref);
+	}
+    break;
+
+  case 169:
+
+/* Line 1806 of yacc.c  */
+#line 2022 "parser.y"
+    {
+		int i = 0;
+		LLVMTypeRef ptr_type;
+		do
+		{
+			if(i)
+				ptr_type = LLVMPointerType(ptr_type, 0);
+			else
+				ptr_type = LLVMPointerType((yyvsp[(1) - (2)].llvm_type_ref)->llvm_type, 0);
+			i++;
+		} while(i < (yyvsp[(2) - (2)].const_int_val));
+		LLVMGetTypeKind(ptr_type);
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(ptr_type, (yyvsp[(1) - (2)].llvm_type_ref)->sign);
+		cl2llvm_type_free((yyvsp[(1) - (2)].llvm_type_ref));
+		LLVMGetTypeKind(type->llvm_type);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 170:
+
+/* Line 1806 of yacc.c  */
+#line 2043 "parser.y"
+    {
+		int ptr_count = 1;
+		(yyval.const_int_val) = ptr_count;
+	}
+    break;
+
+  case 171:
+
+/* Line 1806 of yacc.c  */
+#line 2048 "parser.y"
+    {
+		(yyval.const_int_val) = ++(yyvsp[(1) - (2)].const_int_val);
+	}
+    break;
+
+  case 172:
+
+/* Line 1806 of yacc.c  */
+#line 2055 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 173:
+
+/* Line 1806 of yacc.c  */
+#line 2059 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 174:
+
+/* Line 1806 of yacc.c  */
+#line 2063 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 175:
+
+/* Line 1806 of yacc.c  */
+#line 2067 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 176:
+
+/* Line 1806 of yacc.c  */
+#line 2071 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 177:
+
+/* Line 1806 of yacc.c  */
+#line 2075 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 178:
+
+/* Line 1806 of yacc.c  */
+#line 2079 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 179:
+
+/* Line 1806 of yacc.c  */
+#line 2083 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 180:
+
+/* Line 1806 of yacc.c  */
+#line 2087 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 181:
+
+/* Line 1806 of yacc.c  */
+#line 2091 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 182:
+
+/* Line 1806 of yacc.c  */
+#line 2095 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 183:
+
+/* Line 1806 of yacc.c  */
+#line 2099 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMInt32Type(), 0);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 184:
+
+/* Line 1806 of yacc.c  */
+#line 2105 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMInt32Type(), 0);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 185:
+
+/* Line 1806 of yacc.c  */
+#line 2111 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMInt64Type(), 0);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 186:
+
+/* Line 1806 of yacc.c  */
+#line 2117 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMInt8Type(), 0);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 187:
+
+/* Line 1806 of yacc.c  */
+#line 2123 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMInt16Type(), 1);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 188:
+
+/* Line 1806 of yacc.c  */
+#line 2129 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMInt16Type(), 0);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 189:
+
+/* Line 1806 of yacc.c  */
+#line 2135 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 190:
+
+/* Line 1806 of yacc.c  */
+#line 2139 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 191:
+
+/* Line 1806 of yacc.c  */
+#line 2143 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 192:
+
+/* Line 1806 of yacc.c  */
+#line 2147 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 193:
+
+/* Line 1806 of yacc.c  */
+#line 2151 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 194:
+
+/* Line 1806 of yacc.c  */
+#line 2155 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 195:
+
+/* Line 1806 of yacc.c  */
+#line 2159 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 196:
+
+/* Line 1806 of yacc.c  */
+#line 2163 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 197:
+
+/* Line 1806 of yacc.c  */
+#line 2167 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 198:
+
+/* Line 1806 of yacc.c  */
+#line 2171 "parser.y"
+    {
+		(yyval.llvm_type_ref) = NULL;
+	}
+    break;
+
+  case 199:
+
+/* Line 1806 of yacc.c  */
+#line 2175 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMInt32Type(), 1);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 200:
+
+/* Line 1806 of yacc.c  */
+#line 2181 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMInt32Type(), 1);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 201:
+
+/* Line 1806 of yacc.c  */
+#line 2187 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMInt64Type(), 1);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 202:
+
+/* Line 1806 of yacc.c  */
+#line 2193 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMInt8Type(), 1);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 203:
+
+/* Line 1806 of yacc.c  */
+#line 2199 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMFloatType(), 1);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 204:
+
+/* Line 1806 of yacc.c  */
+#line 2205 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMInt1Type(), 1);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 205:
+
+/* Line 1806 of yacc.c  */
+#line 2211 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMDoubleType(), 1);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 206:
+
+/* Line 1806 of yacc.c  */
+#line 2217 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMInt64Type(), 1);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+  case 207:
+
+/* Line 1806 of yacc.c  */
+#line 2223 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMVoidType(), 1);
+		(yyval.llvm_type_ref) = type;
+
+	}
+    break;
+
+  case 208:
+
+/* Line 1806 of yacc.c  */
+#line 2230 "parser.y"
+    {
+		struct cl2llvm_type_t *type = cl2llvm_type_create_w_init(
+			LLVMHalfType(), 1);
+		(yyval.llvm_type_ref) = type;
+	}
+    break;
+
+
+
+/* Line 1806 of yacc.c  */
+#line 4858 "parser.c"
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
+
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
+                                        yyssp, yytoken)
+      {
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = YYSYNTAX_ERROR;
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == 1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
+            if (!yymsg)
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = 2;
+              }
+            else
+              {
+                yysyntax_error_status = YYSYNTAX_ERROR;
+                yymsgp = yymsg;
+              }
+          }
+        yyerror (yymsgp);
+        if (yysyntax_error_status == 2)
+          goto yyexhaustedlab;
+      }
+# undef YYSYNTAX_ERROR
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
+    }
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+/* Line 2067 of yacc.c  */
+#line 2240 "parser.y"
+
+
+
--- /dev/null
+++ multi2sim-4.1+svn20130603/tools/clcc/cl2llvm/parser.h
@@ -0,0 +1,351 @@
+/* A Bison parser, made by GNU Bison 2.5.  */
+
+/* Bison interface for Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     TOK_ID = 258,
+     TOK_CONST_INT = 259,
+     TOK_CONST_INT_U = 260,
+     TOK_CONST_INT_L = 261,
+     TOK_CONST_INT_UL = 262,
+     TOK_CONST_INT_LL = 263,
+     TOK_CONST_INT_ULL = 264,
+     TOK_CONST_DEC = 265,
+     TOK_CONST_DEC_H = 266,
+     TOK_CONST_DEC_F = 267,
+     TOK_CONST_DEC_L = 268,
+     TOK_CONST_VAL = 269,
+     TOK_STRING = 270,
+     TOK_COMMA = 271,
+     TOK_SEMICOLON = 272,
+     TOK_ELLIPSIS = 273,
+     TOK_SHIFT_LEFT_EQUAL = 274,
+     TOK_SHIFT_RIGHT_EQUAL = 275,
+     TOK_EXCLUSIVE_EQUAL = 276,
+     TOK_OR_EQUAL = 277,
+     TOK_AND_EQUAL = 278,
+     TOK_MOD_EQUAL = 279,
+     TOK_DIV_EQUAL = 280,
+     TOK_MULT_EQUAL = 281,
+     TOK_MINUS_EQUAL = 282,
+     TOK_ADD_EQUAL = 283,
+     TOK_EQUAL = 284,
+     TOK_COLON = 285,
+     TOK_CONDITIONAL = 286,
+     TOK_LOGICAL_OR = 287,
+     TOK_LOGICAL_AND = 288,
+     TOK_BITWISE_OR = 289,
+     TOK_BITWISE_EXCLUSIVE = 290,
+     TOK_BITWISE_AND = 291,
+     TOK_INEQUALITY = 292,
+     TOK_EQUALITY = 293,
+     TOK_LESS_EQUAL = 294,
+     TOK_GREATER_EQUAL = 295,
+     TOK_LESS = 296,
+     TOK_GREATER = 297,
+     TOK_SHIFT_LEFT = 298,
+     TOK_SHIFT_RIGHT = 299,
+     TOK_MINUS = 300,
+     TOK_PLUS = 301,
+     TOK_MOD = 302,
+     TOK_DIV = 303,
+     TOK_MULT = 304,
+     TOK_BITWISE_NOT = 305,
+     TOK_LOGICAL_NEGATE = 306,
+     TOK_PREFIX = 307,
+     TOK_CURLY_BRACE_CLOSE = 308,
+     TOK_CURLY_BRACE_OPEN = 309,
+     TOK_STRUCT_DEREF = 310,
+     TOK_STRUCT_REF = 311,
+     TOK_POSTFIX = 312,
+     TOK_BRACKET_CLOSE = 313,
+     TOK_BRACKET_OPEN = 314,
+     TOK_PAR_CLOSE = 315,
+     TOK_PAR_OPEN = 316,
+     TOK_DECREMENT = 317,
+     TOK_INCREMENT = 318,
+     TOK_AUTO = 319,
+     TOK_BOOL = 320,
+     TOK_BREAK = 321,
+     TOK_CASE = 322,
+     TOK_CHAR = 323,
+     TOK_CHARN = 324,
+     TOK_CONSTANT = 325,
+     TOK_CONST = 326,
+     TOK_CONTINUE = 327,
+     TOK_DEFAULT = 328,
+     TOK_DO = 329,
+     TOK_DOUBLE = 330,
+     TOK_DOUBLE_LONG = 331,
+     TOK_DOUBLEN = 332,
+     TOK_ENUM = 333,
+     TOK_EVENT_T = 334,
+     TOK_EXTERN = 335,
+     TOK_FLOAT = 336,
+     TOK_FLOATN = 337,
+     TOK_FOR = 338,
+     TOK_GLOBAL = 339,
+     TOK_GOTO = 340,
+     TOK_HALF = 341,
+     TOK_IF = 342,
+     TOK_ELSE = 343,
+     TOK_IMAGE2D_T = 344,
+     TOK_IMAGE3D_T = 345,
+     TOK_IMAGE2D_ARRAY_T = 346,
+     TOK_IMAGE1D_T = 347,
+     TOK_IMAGE1D_BUFFER_T = 348,
+     TOK_IMAGE1D_ARRAY_T = 349,
+     TOK_INLINE = 350,
+     TOK_INT = 351,
+     TOK_INT_LONG = 352,
+     TOK_LONG_LONG = 353,
+     TOK_INTN = 354,
+     TOK_INTPTR_T = 355,
+     TOK_KERNEL = 356,
+     TOK_LOCAL = 357,
+     TOK_LONG = 358,
+     TOK_LONGN = 359,
+     TOK_PRIVATE = 360,
+     TOK_PTRDIFF_T = 361,
+     TOK_READ_ONLY = 362,
+     TOK_READ_WRITE = 363,
+     TOK_REGISTER = 364,
+     TOK_RETURN = 365,
+     TOK_SAMPLER_T = 366,
+     TOK_SHORT = 367,
+     TOK_SHORTN = 368,
+     TOK_SIGNED = 369,
+     TOK_SIZEOF = 370,
+     TOK_SIZE_T = 371,
+     TOK_STATIC = 372,
+     TOK_STRUCT = 373,
+     TOK_SWITCH = 374,
+     TOK_TYPEDEF = 375,
+     TOK_TYPENAME = 376,
+     TOK_UCHARN = 377,
+     TOK_UCHAR = 378,
+     TOK_ULONG = 379,
+     TOK_USHORT = 380,
+     TOK_UINT = 381,
+     TOK_UINT_LONG = 382,
+     TOK_UINT_LONG_LONG = 383,
+     TOK_UINTN = 384,
+     TOK_ULONGN = 385,
+     TOK_UINTPTR_T = 386,
+     TOK_UNION = 387,
+     TOK_UNSIGNED = 388,
+     TOK_USHORTN = 389,
+     TOK_VOID = 390,
+     TOK_VOLATILE = 391,
+     TOK_WHILE = 392,
+     TOK_WRITE_ONLY = 393
+   };
+#endif
+/* Tokens.  */
+#define TOK_ID 258
+#define TOK_CONST_INT 259
+#define TOK_CONST_INT_U 260
+#define TOK_CONST_INT_L 261
+#define TOK_CONST_INT_UL 262
+#define TOK_CONST_INT_LL 263
+#define TOK_CONST_INT_ULL 264
+#define TOK_CONST_DEC 265
+#define TOK_CONST_DEC_H 266
+#define TOK_CONST_DEC_F 267
+#define TOK_CONST_DEC_L 268
+#define TOK_CONST_VAL 269
+#define TOK_STRING 270
+#define TOK_COMMA 271
+#define TOK_SEMICOLON 272
+#define TOK_ELLIPSIS 273
+#define TOK_SHIFT_LEFT_EQUAL 274
+#define TOK_SHIFT_RIGHT_EQUAL 275
+#define TOK_EXCLUSIVE_EQUAL 276
+#define TOK_OR_EQUAL 277
+#define TOK_AND_EQUAL 278
+#define TOK_MOD_EQUAL 279
+#define TOK_DIV_EQUAL 280
+#define TOK_MULT_EQUAL 281
+#define TOK_MINUS_EQUAL 282
+#define TOK_ADD_EQUAL 283
+#define TOK_EQUAL 284
+#define TOK_COLON 285
+#define TOK_CONDITIONAL 286
+#define TOK_LOGICAL_OR 287
+#define TOK_LOGICAL_AND 288
+#define TOK_BITWISE_OR 289
+#define TOK_BITWISE_EXCLUSIVE 290
+#define TOK_BITWISE_AND 291
+#define TOK_INEQUALITY 292
+#define TOK_EQUALITY 293
+#define TOK_LESS_EQUAL 294
+#define TOK_GREATER_EQUAL 295
+#define TOK_LESS 296
+#define TOK_GREATER 297
+#define TOK_SHIFT_LEFT 298
+#define TOK_SHIFT_RIGHT 299
+#define TOK_MINUS 300
+#define TOK_PLUS 301
+#define TOK_MOD 302
+#define TOK_DIV 303
+#define TOK_MULT 304
+#define TOK_BITWISE_NOT 305
+#define TOK_LOGICAL_NEGATE 306
+#define TOK_PREFIX 307
+#define TOK_CURLY_BRACE_CLOSE 308
+#define TOK_CURLY_BRACE_OPEN 309
+#define TOK_STRUCT_DEREF 310
+#define TOK_STRUCT_REF 311
+#define TOK_POSTFIX 312
+#define TOK_BRACKET_CLOSE 313
+#define TOK_BRACKET_OPEN 314
+#define TOK_PAR_CLOSE 315
+#define TOK_PAR_OPEN 316
+#define TOK_DECREMENT 317
+#define TOK_INCREMENT 318
+#define TOK_AUTO 319
+#define TOK_BOOL 320
+#define TOK_BREAK 321
+#define TOK_CASE 322
+#define TOK_CHAR 323
+#define TOK_CHARN 324
+#define TOK_CONSTANT 325
+#define TOK_CONST 326
+#define TOK_CONTINUE 327
+#define TOK_DEFAULT 328
+#define TOK_DO 329
+#define TOK_DOUBLE 330
+#define TOK_DOUBLE_LONG 331
+#define TOK_DOUBLEN 332
+#define TOK_ENUM 333
+#define TOK_EVENT_T 334
+#define TOK_EXTERN 335
+#define TOK_FLOAT 336
+#define TOK_FLOATN 337
+#define TOK_FOR 338
+#define TOK_GLOBAL 339
+#define TOK_GOTO 340
+#define TOK_HALF 341
+#define TOK_IF 342
+#define TOK_ELSE 343
+#define TOK_IMAGE2D_T 344
+#define TOK_IMAGE3D_T 345
+#define TOK_IMAGE2D_ARRAY_T 346
+#define TOK_IMAGE1D_T 347
+#define TOK_IMAGE1D_BUFFER_T 348
+#define TOK_IMAGE1D_ARRAY_T 349
+#define TOK_INLINE 350
+#define TOK_INT 351
+#define TOK_INT_LONG 352
+#define TOK_LONG_LONG 353
+#define TOK_INTN 354
+#define TOK_INTPTR_T 355
+#define TOK_KERNEL 356
+#define TOK_LOCAL 357
+#define TOK_LONG 358
+#define TOK_LONGN 359
+#define TOK_PRIVATE 360
+#define TOK_PTRDIFF_T 361
+#define TOK_READ_ONLY 362
+#define TOK_READ_WRITE 363
+#define TOK_REGISTER 364
+#define TOK_RETURN 365
+#define TOK_SAMPLER_T 366
+#define TOK_SHORT 367
+#define TOK_SHORTN 368
+#define TOK_SIGNED 369
+#define TOK_SIZEOF 370
+#define TOK_SIZE_T 371
+#define TOK_STATIC 372
+#define TOK_STRUCT 373
+#define TOK_SWITCH 374
+#define TOK_TYPEDEF 375
+#define TOK_TYPENAME 376
+#define TOK_UCHARN 377
+#define TOK_UCHAR 378
+#define TOK_ULONG 379
+#define TOK_USHORT 380
+#define TOK_UINT 381
+#define TOK_UINT_LONG 382
+#define TOK_UINT_LONG_LONG 383
+#define TOK_UINTN 384
+#define TOK_ULONGN 385
+#define TOK_UINTPTR_T 386
+#define TOK_UNION 387
+#define TOK_UNSIGNED 388
+#define TOK_USHORTN 389
+#define TOK_VOID 390
+#define TOK_VOLATILE 391
+#define TOK_WHILE 392
+#define TOK_WRITE_ONLY 393
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 2068 of yacc.c  */
+#line 50 "parser.y"
+
+	long int const_int_val;
+	unsigned long long const_int_val_ull;
+	double  const_float_val;
+	char * identifier;
+	struct cl2llvm_type_t *llvm_type_ref;
+	struct cl2llvm_val_t *llvm_value_ref;
+	struct list_t * init_list;
+	struct list_t * list_val_t;
+	struct cl2llvm_arg_t *arg_t;
+	struct list_t *arg_list;
+	LLVMBasicBlockRef basic_block_ref;
+	struct cl2llvm_decl_list_t *decl_list;
+
+
+
+/* Line 2068 of yacc.c  */
+#line 343 "parser.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE cl2llvm_yylval;
+
+
--- /dev/null
+++ multi2sim-4.1+svn20130603/tools/clcc/cl2llvm/lex.c
@@ -0,0 +1,3917 @@
+#line 2 "lex.c"
+
+#line 4 "lex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer cl2llvm_yy_create_buffer
+#define yy_delete_buffer cl2llvm_yy_delete_buffer
+#define yy_flex_debug cl2llvm_yy_flex_debug
+#define yy_init_buffer cl2llvm_yy_init_buffer
+#define yy_flush_buffer cl2llvm_yy_flush_buffer
+#define yy_load_buffer_state cl2llvm_yy_load_buffer_state
+#define yy_switch_to_buffer cl2llvm_yy_switch_to_buffer
+#define yyin cl2llvm_yyin
+#define yyleng cl2llvm_yyleng
+#define yylex cl2llvm_yylex
+#define yylineno cl2llvm_yylineno
+#define yyout cl2llvm_yyout
+#define yyrestart cl2llvm_yyrestart
+#define yytext cl2llvm_yytext
+#define yywrap cl2llvm_yywrap
+#define yyalloc cl2llvm_yyalloc
+#define yyrealloc cl2llvm_yyrealloc
+#define yyfree cl2llvm_yyfree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE cl2llvm_yyrestart(cl2llvm_yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int cl2llvm_yyleng;
+
+extern FILE *cl2llvm_yyin, *cl2llvm_yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up cl2llvm_yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up cl2llvm_yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via cl2llvm_yyrestart()), so that the user can continue scanning by
+	 * just pointing cl2llvm_yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when cl2llvm_yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int cl2llvm_yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow cl2llvm_yywrap()'s to do buffer switches
+ * instead of setting up a fresh cl2llvm_yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void cl2llvm_yyrestart (FILE *input_file  );
+void cl2llvm_yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE cl2llvm_yy_create_buffer (FILE *file,int size  );
+void cl2llvm_yy_delete_buffer (YY_BUFFER_STATE b  );
+void cl2llvm_yy_flush_buffer (YY_BUFFER_STATE b  );
+void cl2llvm_yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void cl2llvm_yypop_buffer_state (void );
+
+static void cl2llvm_yyensure_buffer_stack (void );
+static void cl2llvm_yy_load_buffer_state (void );
+static void cl2llvm_yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER cl2llvm_yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE cl2llvm_yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE cl2llvm_yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE cl2llvm_yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *cl2llvm_yyalloc (yy_size_t  );
+void *cl2llvm_yyrealloc (void *,yy_size_t  );
+void cl2llvm_yyfree (void *  );
+
+#define yy_new_buffer cl2llvm_yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        cl2llvm_yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            cl2llvm_yy_create_buffer(cl2llvm_yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        cl2llvm_yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            cl2llvm_yy_create_buffer(cl2llvm_yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define cl2llvm_yywrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *cl2llvm_yyin = (FILE *) 0, *cl2llvm_yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int cl2llvm_yylineno;
+
+int cl2llvm_yylineno = 1;
+
+extern char *cl2llvm_yytext;
+#define yytext_ptr cl2llvm_yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up cl2llvm_yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	cl2llvm_yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 145
+#define YY_END_OF_BUFFER 146
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[809] =
+    {   0,
+        0,    0,  146,  144,  143,    1,  142,   63,  144,   37,
+       60,  144,   27,   28,   35,   33,   24,   34,   68,   36,
+       12,   12,   26,   25,   51,   38,   50,   56,  141,   29,
+       30,   58,  141,  141,  141,  141,  141,  141,  141,  141,
+      141,  141,  141,  141,  141,  141,  141,  141,  141,  141,
+      141,  141,   31,   59,   32,   57,   67,    0,    4,   44,
+       61,   45,    0,    0,   42,   52,   40,   53,   41,   69,
+        0,   19,    0,    0,   43,   19,   11,   19,    0,   21,
+       20,   22,    0,    0,   22,    0,   12,   22,    0,   22,
+        0,   54,   65,   66,   64,   55,    0,  141,   47,  141,
+
+      141,  141,  141,  141,  141,  141,  141,   80,  141,  141,
+      141,  141,  141,  141,  141,  141,  141,   94,  141,  141,
+      141,  141,  141,  141,  141,  141,  141,  141,  141,  141,
+      141,  141,  141,  141,  141,  141,  141,  141,  141,  141,
+       46,   62,   23,   39,    0,   22,    0,    0,    0,    3,
+       19,    0,   18,   16,   16,   15,   15,   15,    5,   16,
+       16,    0,   15,   15,    0,    0,    0,   15,   15,   15,
+        0,    0,    0,   15,   15,    0,   49,   48,  141,  141,
+      141,  141,  141,  141,  141,  141,  141,  141,  141,  141,
+      141,  141,  141,  141,  141,  141,  141,  141,   90,  141,
+
+      141,  141,  141,  141,  102,  141,  141,  141,  141,  141,
+      141,  141,  141,  141,  141,  141,  141,  141,  141,  141,
+      141,  141,  141,  141,  141,  141,  141,  141,  141,  141,
+      141,  141,    0,   19,    2,   17,    7,    6,    7,    6,
+        0,    0,   17,    0,    0,    0,    0,   17,   17,    0,
+        0,  141,  141,  141,  141,  141,  141,  141,   70,   71,
+      141,   73,   74,  141,  141,  141,  141,   84,   85,  141,
+      141,  141,  141,   92,   93,  141,  141,    0,  141,  103,
+      141,  141,  141,  107,  141,  141,  141,  141,  141,  141,
+      141,  141,  141,  141,  141,  141,  141,  141,  141,  126,
+
+      141,  141,  141,  141,  135,  141,  141,  141,    8,    8,
+        9,    9,    9,    8,    8,    9,    9,   14,    0,    0,
+        0,    0,    0,   15,   15,   14,    0,  141,  141,  141,
+      141,  141,  141,  141,   72,    0,  141,   75,   77,  141,
+      141,  141,  141,  141,   88,  141,  141,  141,    0,    0,
+        0,  141,  141,  106,    0,  141,  109,  141,  141,  141,
+      141,  141,  141,  141,  115,  141,  141,  141,  141,  141,
+      141,  141,  124,  141,  129,  141,  127,  132,  141,  141,
+      141,  140,  141,   10,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,  141,  141,  141,  141,  141,
+
+      141,  141,    0,  141,  141,  141,   81,  141,   87,  141,
+       89,   91,  141,  141,  141,  101,    0,    0,    0,    0,
+      141,  105,    0,    0,    0,    0,  141,  141,  141,  141,
+      141,  141,  113,  141,    0,  141,  116,  102,  118,  117,
+      119,  120,  121,  141,  141,  125,  141,  141,  131,  141,
+      133,  141,  141,    0,    0,  141,  141,  141,  141,  141,
+      141,    0,  141,  141,   79,    0,  141,   83,   86,  141,
+      141,  141,    0,    0,    0,    0,  141,    0,    0,    0,
+        0,  141,  110,  141,  141,  141,  141,  141,    0,    0,
+        0,    0,  122,  141,  141,  141,  134,  141,  141,    0,
+
+        0,  141,  141,  141,  141,  141,    0,   76,   78,    0,
+      141,  141,  141,  107,    0,    0,    0,  104,    0,  107,
+        0,    0,   95,  141,  141,  141,  112,  141,    0,    0,
+        0,    0,    0,    0,    0,  141,  126,  139,  141,   13,
+       13,  141,  141,  141,  141,    0,    0,  141,  141,   98,
+      141,   96,    0,  115,    0,    0,    0,    0,  108,    0,
+      111,  136,  141,  114,  115,    0,    0,    0,    0,    0,
+        0,    0,  130,    0,  141,    0,  141,  141,  141,    0,
+        0,  141,  141,  141,    0,    0,    0,  102,    0,    0,
+        0,    0,    0,    0,  138,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,  137,  141,  141,   74,
+       82,  141,  141,  141,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,  123,    0,    0,
+        0,    0,    0,  141,  141,  141,    0,    0,    0,  126,
+        0,    0,    0,    0,    0,    0,  115,    0,    0,    0,
+        0,  126,    0,    0,  141,  141,  141,  108,    0,    0,
+        0,  108,    0,  108,    0,  127,    0,    0,    0,    0,
+      124,    0,  127,    0,  141,  141,  141,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,  133,    0,
+      123,    0,    0,    0,  133,  100,  141,   97,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,   99,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+      127,  133,  127,    0,    0,  127,    0,    0,  127,    0,
+        0,    0,    0,    0,  127,    0,  127,    0,    0,    0,
+        0,    0,    0,    0,  128,    0,    0,  128,  123,    0,
+        0,  128,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,  128,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    4,    5,    6,    1,    1,    7,    8,    9,   10,
+       11,   12,   13,   14,   15,   16,   17,   18,   19,   20,
+       21,   22,   23,   24,   23,   25,   26,   27,   28,   29,
+       30,   31,   32,    1,   33,   33,   33,   33,   34,   35,
+       36,   37,   36,   36,   36,   38,   36,   36,   36,   36,
+       36,   36,   36,   36,   39,   36,   36,   40,   36,   36,
+       41,   42,   43,   44,   45,   46,   47,   48,   49,   50,
+
+       51,   52,   53,   54,   55,   36,   56,   57,   58,   59,
+       60,   61,   36,   62,   63,   64,   65,   66,   67,   68,
+       69,   70,   71,   72,   73,   74,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[75] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    1,
+        1,    1,    1,    1,    1,    1,    1,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    1,    1,    1,    1,
+        1,    1,    4,    4,    3,    5,    6,    6,    5,    5,
+        1,    1,    1,    1,    5,    7,    4,    4,    4,    4,
+        4,    3,    5,    6,    5,    5,    6,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
+        1,    1,    1,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[817] =
+    {   0,
+        0,    0, 1661, 1662, 1662, 1662, 1662, 1630, 1653, 1628,
+       67, 1615, 1662, 1662, 1626,   63, 1662,   64,   62,   79,
+       94,  147, 1662, 1662,   60, 1625,   68, 1662, 1645, 1662,
+     1662, 1623,   91,   92,   93,   83,   96,  143,  117,  118,
+       94,  102,   98,  116,   95,  126,   99,  170,  114,  183,
+      129,  182, 1662,   92, 1662, 1662, 1662, 1646, 1662, 1662,
+     1662, 1662,   97,  184, 1662, 1662, 1662, 1662, 1662, 1662,
+     1635,  229, 1638, 1646, 1662,  269,  259,  238,  315, 1662,
+     1662,  156,   83,    0,  158,  157,    0,  165,  169,  262,
+      170, 1618, 1662, 1662, 1662, 1617, 1604, 1636, 1662,  293,
+
+      171,  210,  214,  211,  196,  219,  224,  260,  222,  264,
+      259,  232,  296,  270,  299,  300,  149, 1635,  230,  304,
+      303,  308,  262,  263,  322,  305,  334,  302,  335,  336,
+      338,  339,  342,  344,  354,  357,  361,  362,  363,  366,
+     1662, 1662, 1662, 1662,  409, 1662, 1631, 1625, 1638, 1662,
+        0,  418,  352,  334,  337, 1662,  340,  344,  407,  342,
+      346, 1581,  353,  356, 1576,  384,  386,  409,  414,  416,
+      411,  417, 1579,  420,  423, 1574, 1662, 1662,  407,  448,
+      417,  451,  454,  456,  460,  461,  466,  477,  469,  474,
+      475,  478,  236,  480,  482,  483,  481,  486, 1627,  487,
+
+      484,  485,  488,  490,  544,  491,  504,  499,  492,  489,
+      506,  508,  494,  495,  493,  497,  503,  510,  509,  505,
+      517,  520,  521,  518,  519,  525,  548,  558,  563,  565,
+      566,  567,  568,  562, 1662, 1662,  539,  541,  545,  563,
+     1582, 1579,  568, 1568,  570, 1593,  571,  572,  583, 1578,
+     1575,  571,  586,  606,  608,  615,  617,  623, 1620, 1619,
+       68, 1618,  640,  625,  626,  627,  629, 1617, 1616,  630,
+      636,  632,  638, 1615, 1614,  642,  641,  650,  371, 1613,
+      646,  654,  647,  699,  649,  662,  657,  663,  664,  666,
+      665,  667,  674,  678,  671,  668,  681,  679,  670,  724,
+
+      658,  675,  682,  686, 1612,  673,  688,  690,  675,  677,
+     1662,  698,  709,  711,  712,  714,  715, 1662, 1567,  716,
+      718,  721,  722,  723,  725, 1562, 1565,  748,  749,  756,
+      758,  759,  760,  765, 1608,  789,  772, 1607,  761,  774,
+      775,  777,  778,  780,  797,  785,  793,  786, 1555,  455,
+     1555,  789,  790, 1604,  832,  800, 1603,  791,  792,  794,
+      795,  811,  798,  812,  846,  822,  817,  818,  829,  821,
+      834,  835,  871,  836, 1602,  831,  885, 1601,  844,  845,
+      860, 1600,  855, 1662, 1549,  820,  841,  845,  861,  863,
+      873,  870,  875, 1547, 1547,  852,  875,  908,  864,  910,
+
+      915,  914, 1550,  867,  916,  865,  942,  922, 1595,  924,
+     1594, 1593,  925,  927,  928, 1592, 1541, 1539, 1545, 1534,
+      929, 1587, 1535, 1535, 1533, 1533,  931,  932,  930,  933,
+      934,  938, 1582,  940,  948,  944, 1581,  991, 1580, 1579,
+     1578, 1577, 1576,  945,  946, 1575,  947,  949, 1574,  957,
+      995,  962,  963, 1531, 1530,  960,  970,  971,  975,  976,
+      979, 1527,  978,  981, 1570, 1027,  982, 1569, 1568,  989,
+      990,  992, 1523, 1513, 1515, 1518,  996, 1507, 1507, 1511,
+     1506, 1001, 1559, 1003, 1009, 1012, 1013, 1016, 1508, 1511,
+     1506, 1042,  370, 1017, 1024, 1029, 1555, 1031, 1040, 1513,
+
+     1512, 1041, 1032, 1042, 1045, 1038, 1502, 1551, 1550, 1498,
+     1046, 1043, 1047, 1055, 1493, 1505, 1502, 1545, 1505, 1066,
+     1499, 1496, 1541, 1054, 1055, 1062, 1540, 1063, 1484, 1494,
+     1483, 1491, 1485, 1489, 1073, 1067, 1076, 1533, 1064, 1662,
+     1476, 1077, 1072, 1078, 1079, 1489, 1480, 1080, 1083, 1529,
+     1087, 1528, 1100, 1471, 1485, 1475, 1476, 1110, 1113, 1479,
+     1522, 1521, 1086, 1520, 1141, 1469, 1472, 1479, 1461, 1464,
+     1464, 1467, 1512, 1148, 1097, 1461, 1099, 1100, 1113, 1469,
+     1465, 1110, 1111, 1114, 1457, 1457, 1456, 1662, 1463, 1462,
+     1452, 1452, 1151, 1451, 1500, 1156, 1457, 1454, 1444, 1443,
+
+     1440, 1450, 1448, 1442, 1440, 1445, 1489, 1123, 1116, 1662,
+     1662, 1126, 1125, 1131, 1438, 1433, 1432, 1444, 1434, 1429,
+     1432, 1431, 1438, 1429, 1437, 1427, 1421, 1177, 1425, 1436,
+     1418, 1422, 1420, 1121, 1137, 1130, 1426, 1423, 1422, 1180,
+     1423, 1420, 1410, 1410, 1422, 1408, 1662, 1419, 1189, 1418,
+     1406, 1192, 1414, 1404, 1153, 1138, 1162, 1206, 1412, 1411,
+     1210, 1215, 1410, 1220, 1407, 1223, 1406, 1410, 1404, 1408,
+     1662, 1226, 1229, 1393, 1177, 1192, 1178, 1232, 1397, 1396,
+     1394, 1399, 1236, 1393, 1241, 1398, 1245, 1397, 1251, 1396,
+     1254, 1388, 1393, 1257, 1260, 1437, 1206, 1436, 1384, 1391,
+
+     1388, 1379, 1350, 1342, 1349, 1339, 1338, 1337, 1335, 1335,
+     1272, 1333, 1275, 1332, 1330, 1329, 1327, 1278, 1377, 1322,
+     1334, 1333, 1329, 1319, 1317, 1328, 1314, 1325, 1311, 1315,
+     1321, 1312, 1319, 1310, 1315, 1305, 1302, 1306, 1305, 1308,
+     1304, 1662, 1282, 1296, 1304, 1662, 1303, 1307, 1288, 1303,
+     1305, 1290, 1303, 1288, 1291, 1280, 1301, 1290, 1268, 1278,
+     1269, 1305, 1275, 1260, 1313, 1316, 1251, 1319, 1662, 1322,
+     1332, 1335, 1251, 1240, 1238, 1237, 1229, 1338, 1227, 1213,
+     1344, 1211, 1209, 1347, 1217, 1213, 1206, 1200, 1199, 1187,
+     1161, 1151, 1143, 1130, 1110, 1102, 1106, 1662,  806,  656,
+
+      358,  322,  324,  218,  222,  157,   80, 1662, 1402, 1408,
+     1414, 1420, 1427, 1432, 1434, 1438
+    } ;
+
+static yyconst flex_int16_t yy_def[817] =
+    {   0,
+      808,    1,  808,  808,  808,  808,  808,  808,  809,  808,
+      808,  810,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  811,  808,
+      808,  808,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  808,  808,  808,  808,  808,  809,  808,  808,
+      808,  808,  810,  810,  808,  808,  808,  808,  808,  808,
+      808,  808,  812,  813,  808,  808,   21,   77,  808,  808,
+      808,  808,  808,  814,  808,  808,   22,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  810,  811,  808,  811,
+
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      808,  808,  808,  808,  808,  808,  812,  812,  813,  808,
+       76,  808,  815,  808,  808,  808,  808,  808,  814,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  808,  816,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  808,  811,  811,
+      811,  811,  811,  263,  811,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+
+      811,  811,  811,  811,  811,  811,  811,  811,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  811,  811,  811,
+      811,  811,  811,  811,  811,  808,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  808,  808,
+      808,  811,  811,  811,  808,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  263,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  811,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  811,  811,  811,  811,  811,
+
+      811,  811,  808,  811,  811,  811,  263,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  808,  808,  808,  808,
+      811,  811,  808,  808,  808,  808,  811,  811,  811,  811,
+      811,  811,  811,  811,  808,  811,  811,  811,  811,  811,
+      811,  811,  811,  811,  811,  811,  811,  811,  811,  811,
+      811,  811,  811,  808,  808,  811,  811,  811,  811,  811,
+      811,  808,  811,  811,  811,  808,  811,  811,  811,  811,
+      811,  811,  808,  808,  808,  808,  811,  808,  808,  808,
+      808,  811,  811,  811,  811,  811,  811,  811,  808,  808,
+      808,  808,  811,  811,  811,  811,  811,  811,  811,  808,
+
+      808,  811,  811,  811,  811,  811,  808,  811,  811,  808,
+      811,  811,  811,  808,  808,  808,  808,  811,  808,  808,
+      808,  808,  811,  811,  811,  811,  811,  811,  808,  808,
+      808,  808,  808,  808,  808,  811,  811,  811,  811,  808,
+      808,  811,  811,  811,  811,  808,  808,  811,  811,  811,
+      811,  811,  808,  808,  808,  808,  808,  808,  808,  808,
+      811,  811,  811,  811,  808,  808,  808,  808,  808,  808,
+      808,  808,  811,  808,  811,  808,  811,  811,  811,  808,
+      808,  811,  811,  811,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  811,  808,  808,  808,  808,  808,
+
+      808,  808,  808,  808,  808,  808,  811,  811,  811,  808,
+      808,  811,  811,  811,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  811,  811,  811,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  811,  811,  811,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  811,  811,  811,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  811,  811,  811,  808,  808,
+
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  811,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+
+      808,  808,  808,  808,  808,  808,  808,    0,  808,  808,
+      808,  808,  808,  808,  808,  808
+    } ;
+
+static yyconst flex_int16_t yy_nxt[1737] =
+    {   0,
+        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
+       14,   15,   16,   17,   18,   19,   20,   21,   22,   22,
+       22,   22,   22,   22,   22,   22,   23,   24,   25,   26,
+       27,   28,   29,   29,   29,   29,   29,   29,   29,   29,
+       30,    4,   31,   32,   33,    4,   34,   35,   36,   37,
+       38,   39,   40,   41,   42,   43,   44,   45,   29,   29,
+       46,   47,   48,   49,   50,   51,   52,   29,   29,   29,
+       53,   54,   55,   56,   61,   66,  808,   71,   68,   72,
+       72,   72,   72,   72,   72,   72,   72,   72,   92,   93,
+       73,   97,   67,   69,   70,   74,   62,   95,   96,   97,
+
+       97,   97,   97,   97,   97,  143,   97,   97,   75,   76,
+       97,   77,   77,   77,   77,   77,   77,   77,   78,   78,
+      157,  141,   97,  335,   97,   97,   97,   79,   80,  104,
+       81,   82,   83,   84,   97,  100,  105,   97,   64,  158,
+      117,  123,  106,  798,   79,   80,  107,   81,  121,  126,
+       85,   97,  102,  118,  103,  108,  101,  808,   86,  119,
+      120,   84,   76,  142,   87,   87,   87,   87,   87,   87,
+       87,   87,   87,  113,  115,  122,  114,  116,   97,  808,
+       79,   80,  132,   81,   88,   89,  808,  124,  138,  125,
+       97,   97,   63,  154,  163,  160,  156,   79,   80,  109,
+
+       81,  110,  166,   90,  808,  202,  169,  174,  111,  798,
+      112,   91,  155,  164,  161,  165,  127,  162,  808,  808,
+      156,  167,  808,  128,  129,  170,  175,  808,  176,  168,
+      808,  133,  808,  130,  186,  139,  131,  134,  808,  135,
+      808,  136,  190,  140,  808,  137,   72,   72,   72,   72,
+       72,   72,   72,   72,   72,   78,   78,   78,   78,   78,
+       78,   78,  145,   80,  188,   81,  146,  808,  808,  187,
+      808,  808,  808,  189,  798,  192,  203,  191,  808,  145,
+       80,  798,   81,  267,  194,  146,  151,  151,  151,  151,
+      151,  151,  151,  151,  151,  197,  146,  808,  808,  171,
+
+      168,  808,  145,   80,  808,   81,  146,  808,  808,  196,
+      808,  808,  808,  808,  209,  146,  808,  210,  172,  145,
+       80,  173,   81,  808,  193,  146,  808,  152,  195,  152,
+      808,  199,  153,  153,  153,  153,  153,  153,  153,  153,
+      153,  179,  808,  808,  808,  180,  808,  808,  181,  182,
+      808,  212,  808,  183,  184,  198,  207,  213,  200,  185,
+      204,  216,  808,  201,  206,  808,  208,  205,  214,  808,
+      808,  808,  236,  535,  808,  236,  798,  236,  808,  808,
+      236,  236,  219,  211,  236,  798,   80,  217,   81,  146,
+      236,  215,  221,  236,  280,  223,  236,  220,  236,  222,
+
+      236,  236,  224,   80,  218,   81,  236,  798,  146,  236,
+      236,  226,  236,  225,  228,  808,  229,  231,  230,  227,
+      232,  233,  243,  233,  243,  808,  234,  234,  234,  234,
+      234,  234,  234,  234,  234,  153,  153,  153,  153,  153,
+      153,  153,  153,  153,  237,  238,  244,  245,  243,  243,
+      243,  248,  245,  248,  245,  243,  808,  248,  245,  808,
+      248,  245,  808,  239,  808,  246,  252,  254,  808,  808,
+      249,  240,  249,  247,  808,  243,  249,  808,  247,  249,
+      247,  243,  808,  808,  247,  808,  808,  247,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+
+      808,  808,  808,  808,  253,  808,  257,  808,  418,  419,
+      255,  808,  808,  808,  808,  256,  808,  808,  808,  262,
+      259,  258,  260,  261,  266,  808,  808,  808,  808,  808,
+      268,  271,  272,  808,  273,  263,  275,  264,  265,  269,
+      276,  270,  285,  274,  277,  278,  278,  278,  289,  282,
+      283,  284,  808,  291,  286,  287,  808,  288,  292,  290,
+      294,  293,  279,  280,  280,  280,  808,  299,  280,  296,
+      298,  808,  295,  808,  808,  808,  309,  301,  312,  808,
+      297,  300,  314,  311,  302,  234,  234,  234,  234,  234,
+      234,  234,  234,  234,  808,  310,   80,  313,   81,  146,
+
+      316,  315,  303,  311,  281,  320,  321,  168,  168,  320,
+      321,  306,  305,   80,  808,   81,  808,  304,  146,  317,
+      320,  325,  307,  808,  322,  808,  168,  168,  322,  328,
+      308,  808,  323,  808,  808,  808,  324,  808,  808,  322,
+      808,  336,  336,  336,  808,  329,  808,  323,  808,  808,
+      808,  278,  278,  278,  808,  808,  331,  808,  337,  338,
+      338,  338,  808,  333,  338,  808,  808,  330,  358,  332,
+      808,  808,  808,  808,  808,  808,  808,  334,  808,  808,
+      340,  808,  808,  808,  346,  342,  808,  808,  339,  808,
+      808,  341,  347,  343,  808,  345,  808,  344,  808,  348,
+
+      355,  355,  355,  354,  353,  798,  349,  361,  359,  352,
+      377,  360,  350,  384,  351,  384,  370,  356,  357,  357,
+      357,  364,  367,  357,  366,  369,  362,  363,  372,  371,
+      365,  373,  808,  378,  379,  384,  381,  368,  382,  384,
+      383,  384,  374,  375,  375,  375,  384,  380,  375,  384,
+      384,  384,  384,  166,  384,  386,  808,  808,  171,  388,
+      390,  245,  392,  245,  808,  384,  808,  808,  808,  808,
+      384,  384,  167,  808,  387,  384,  384,  172,  389,  391,
+      808,  393,  808,  808,  376,  808,  808,  247,  808,  247,
+      336,  336,  336,  808,  808,  338,  397,  808,  808,  808,
+
+      808,  808,  808,  808,  399,  808,  808,  404,  808,  401,
+      396,  413,  414,  415,  398,  410,  411,  411,  411,  808,
+      808,  411,  408,  357,  400,  808,  808,  407,  402,  808,
+      808,  406,  405,  355,  355,  355,  416,  808,  409,  808,
+      427,  412,  808,  808,  808,  429,  422,  435,  435,  435,
+      421,  403,  808,  808,  430,  428,  433,  243,  798,  375,
+      808,  431,  434,  808,  436,  437,  437,  437,  808,  440,
+      437,  438,  808,  808,  432,  808,  243,  441,  243,  808,
+      439,  423,  243,  808,  442,  444,  424,  443,  425,  445,
+      446,  446,  446,  808,  447,  446,  426,  243,  243,  453,
+
+      243,  243,  450,  448,  449,  449,  449,  243,  451,  449,
+      243,  168,  243,  168,  452,  456,  808,  243,  808,  243,
+      354,  457,  808,  808,  808,  463,  243,  168,  465,  243,
+      808,  243,  808,  808,  168,  808,  808,  808,  808,  808,
+      808,  808,  808,  466,  466,  466,  808,  411,  808,  435,
+      435,  435,  808,  808,  808,  808,  459,  808,  458,  460,
+      467,  468,  468,  468,  461,  808,  468,  437,  808,  446,
+      808,  808,  449,  477,  470,  482,  471,  472,  808,  808,
+      464,  484,  483,  808,  808,  469,  808,  808,  487,  808,
+      808,  485,  492,  492,  492,  486,  493,  808,  808,  808,
+
+      808,  488,  489,  808,  808,  468,  502,  495,  494,  808,
+      490,  808,  491,  496,  497,  497,  497,  808,  498,  497,
+      808,  808,  499,  506,  808,  808,  412,  422,  466,  466,
+      466,  509,  808,  511,  512,  504,  513,  808,  503,  808,
+      808,  508,  505,  492,  492,  492,  808,  524,  808,  808,
+      808,  808,  497,  808,  808,  808,  553,  553,  553,  518,
+      528,  536,  808,  808,  523,  525,  526,  558,  558,  558,
+      808,  808,  808,  537,  527,  808,  535,  574,  574,  574,
+      808,  538,  483,  510,  808,  808,  808,  808,  808,  551,
+      532,  808,  548,  549,  808,  808,  533,  545,  539,  542,
+
+      543,  553,  553,  553,  534,  808,  544,  808,  808,  550,
+      552,  558,  558,  558,  593,  593,  593,  561,  808,  808,
+      575,  808,  808,  562,  808,  563,  564,  571,  577,  808,
+      573,  808,  578,  808,  808,  572,  595,  579,  808,  808,
+      508,  582,  596,  596,  596,  808,  808,  583,  584,  574,
+      574,  574,  593,  593,  593,  798,  585,  596,  596,  596,
+      807,  808,  613,  608,  586,  607,  591,  562,  806,  609,
+      808,  612,  634,  595,  592,  614,  635,  636,  649,  649,
+      649,  661,  661,  661,  607,  808,  808,  656,  805,  655,
+      649,  649,  649,  672,  672,  672,  603,  675,  657,  676,
+
+      808,  804,  604,  798,  605,  621,  677,  678,  678,  678,
+      606,  661,  661,  661,  808,  622,  683,  683,  683,  803,
+      624,  685,  685,  685,  687,  687,  687,  672,  672,  672,
+      694,  694,  694,  678,  678,  678,  697,  683,  683,  683,
+      696,  698,  685,  685,  685,  802,  687,  687,  687,  801,
+      800,  669,  711,  711,  711,  713,  713,  713,  694,  694,
+      694,  718,  718,  718,  799,  798,  681,  797,  795,  719,
+      794,  792,  682,  711,  711,  711,  713,  713,  713,  718,
+      718,  718,  692,  762,  762,  762,  791,  789,  693,  766,
+      766,  766,  770,  770,  770,  788,  699,  787,  786,  708,
+
+      704,  709,  771,  771,  771,  706,  762,  762,  762,  785,
+      780,  716,  777,  717,  778,  778,  778,  766,  766,  766,
+      781,  781,  781,  770,  770,  770,  732,  776,  774,  734,
+      773,  742,  739,  771,  771,  771,  784,  784,  784,  778,
+      778,  778,  772,  742,  767,  781,  781,  781,  784,  784,
+      784,  769,  769,  742,  742,  768,  765,  764,  763,  742,
+      761,  775,  760,  759,  758,  757,  756,  755,  754,  753,
+      752,  751,  779,  750,  749,  748,  747,  746,  782,  745,
+      744,  743,  742,  741,  740,  808,  738,  737,  783,  736,
+      735,  733,  790,  731,  730,  729,  728,  727,  793,  726,
+
+      725,  796,   58,   58,   58,   58,   58,   58,   63,  724,
+       63,   63,   63,   63,   63,   98,   98,   98,   98,   98,
+      147,  147,  147,  147,  147,  147,  147,  149,  149,  149,
+      149,  149,  149,  149,  159,  159,  153,  723,  722,  153,
+      234,  721,  720,  234,  808,  808,  715,  714,  712,  710,
+      707,  705,  703,  702,  701,  700,  695,  691,  690,  689,
+      688,  686,  684,  680,  679,  674,  673,  671,  670,  668,
+      667,  666,  665,  664,  663,  662,  660,  659,  658,  654,
+      653,  652,  651,  650,  647,  648,  647,  646,  645,  644,
+      643,  642,  641,  640,  639,  638,  637,  808,  633,  632,
+
+      631,  630,  629,  628,  627,  610,  626,  625,  808,  623,
+      620,  619,  611,  618,  617,  616,  615,  611,  610,  176,
+      808,  602,  601,  600,  588,  599,  598,  597,  808,  808,
+      808,  594,  590,  589,  588,  587,  808,  808,  581,  580,
+      576,  808,  570,  569,  568,  567,  566,  565,  808,  808,
+      560,  559,  557,  808,  556,  555,  554,  547,  808,  808,
+      546,  541,  540,  808,  531,  530,  529,  808,  522,  521,
+      520,  519,  517,  516,  515,  514,  808,  808,  808,  507,
+      501,  500,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  481,  480,  479,  478,  808,  476,  475,  474,  473,
+
+      808,  808,  808,  808,  462,  455,  173,  454,  808,  808,
+      808,  808,  808,  420,  417,  808,  808,  395,  394,  385,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  327,
+      326,  168,  168,  319,  318,  808,  251,  250,  242,  241,
+      150,  235,  148,  808,  808,   64,  178,  177,  150,  148,
+      144,   59,   99,   97,   94,   65,   64,   60,   59,   57,
+      808,    3,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808
+    } ;
+
+static yyconst flex_int16_t yy_chk[1737] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,   11,   16,  261,   19,   18,   19,
+       19,   19,   19,   19,   19,   19,   19,   19,   25,   25,
+       20,   36,   16,   18,   18,   20,   11,   27,   27,   33,
+
+       34,   35,   41,   45,   37,   63,   43,   47,   20,   21,
+       42,   21,   21,   21,   21,   21,   21,   21,   21,   21,
+       83,   54,   49,  261,   44,   39,   40,   21,   21,   36,
+       21,   21,   21,   21,   46,   33,   36,   51,   63,   83,
+       41,   45,   36,  807,   21,   21,   37,   21,   43,   47,
+       21,   38,   35,   42,   35,   37,   34,  117,   21,   42,
+       42,   21,   22,   54,   22,   22,   22,   22,   22,   22,
+       22,   22,   22,   39,   40,   44,   39,   40,   48,  101,
+       22,   22,   49,   22,   22,   22,   64,   46,   51,   46,
+       52,   50,   64,   82,   86,   85,   85,   22,   22,   38,
+
+       22,   38,   88,   22,  105,  117,   89,   91,   38,  806,
+       38,   22,   82,   86,   85,   86,   48,   85,  102,  104,
+       82,   88,  103,   48,   48,   89,   91,  106,   91,   88,
+      109,   50,  107,   48,  101,   52,   48,   50,  119,   50,
+      112,   50,  105,   52,  193,   50,   72,   72,   72,   72,
+       72,   72,   72,   72,   72,   78,   78,   78,   78,   78,
+       78,   78,   72,   72,  103,   72,   72,  111,  108,  102,
+      123,  124,  110,  104,  805,  107,  119,  106,  114,   72,
+       72,  804,   72,  193,  109,   72,   76,   76,   76,   76,
+       76,   76,   76,   76,   76,  112,   77,   77,   77,   90,
+
+       90,  100,   76,   76,  113,   76,   76,  115,  116,  111,
+      128,  121,  120,  126,  123,   77,  122,  124,   90,   76,
+       76,   90,   76,   77,  108,   76,   77,   79,  110,   79,
+      125,  114,   79,   79,   79,   79,   79,   79,   79,   79,
+       79,  100,  127,  129,  130,  100,  131,  132,  100,  100,
+      133,  126,  134,  100,  100,  113,  122,  126,  115,  100,
+      120,  128,  135,  116,  121,  136,  122,  120,  126,  137,
+      138,  139,  154,  493,  140,  155,  803,  157,  493,  279,
+      160,  158,  130,  125,  161,  802,  153,  129,  153,  153,
+      163,  127,  131,  164,  279,  133,  157,  130,  154,  132,
+
+      158,  155,  134,  153,  129,  153,  160,  801,  153,  163,
+      161,  136,  164,  135,  137,  179,  138,  139,  138,  136,
+      140,  145,  166,  145,  167,  181,  145,  145,  145,  145,
+      145,  145,  145,  145,  145,  152,  152,  152,  152,  152,
+      152,  152,  152,  152,  159,  159,  168,  168,  166,  171,
+      167,  169,  169,  170,  170,  172,  180,  174,  174,  182,
+      175,  175,  183,  159,  184,  168,  179,  181,  185,  186,
+      169,  159,  170,  168,  187,  171,  174,  189,  169,  175,
+      170,  172,  190,  191,  174,  188,  192,  175,  194,  197,
+      195,  196,  201,  202,  198,  200,  203,  210,  204,  206,
+
+      209,  215,  213,  214,  180,  216,  184,  208,  350,  350,
+      182,  217,  207,  220,  211,  183,  212,  219,  218,  189,
+      186,  185,  187,  188,  192,  221,  224,  225,  222,  223,
+      194,  197,  198,  226,  200,  190,  202,  191,  191,  195,
+      203,  196,  209,  201,  204,  205,  205,  205,  213,  206,
+      207,  208,  205,  215,  210,  211,  227,  212,  216,  214,
+      218,  217,  205,  205,  205,  205,  228,  223,  205,  220,
+      222,  229,  219,  230,  231,  232,  237,  225,  238,  252,
+      221,  224,  239,  239,  226,  233,  233,  233,  233,  233,
+      233,  233,  233,  233,  253,  237,  234,  238,  234,  234,
+
+      240,  239,  227,  237,  205,  243,  243,  245,  247,  248,
+      248,  230,  229,  234,  254,  234,  255,  228,  234,  240,
+      249,  249,  231,  256,  243,  257,  245,  247,  248,  252,
+      232,  258,  243,  264,  265,  266,  248,  267,  270,  249,
+      272,  263,  263,  263,  271,  253,  273,  249,  263,  277,
+      276,  278,  278,  278,  281,  283,  255,  285,  263,  263,
+      263,  263,  282,  257,  263,  287,  301,  254,  285,  256,
+      286,  288,  289,  291,  290,  292,  296,  258,  299,  295,
+      265,  306,  293,  302,  273,  267,  294,  298,  264,  297,
+      303,  266,  276,  270,  304,  272,  307,  271,  308,  277,
+
+      284,  284,  284,  283,  282,  800,  278,  288,  286,  281,
+      301,  287,  278,  309,  278,  310,  296,  284,  284,  284,
+      284,  291,  294,  284,  293,  295,  289,  290,  298,  297,
+      292,  299,  300,  302,  303,  312,  306,  294,  307,  309,
+      308,  310,  300,  300,  300,  300,  313,  304,  300,  314,
+      315,  316,  317,  320,  312,  321,  328,  329,  322,  323,
+      324,  324,  325,  325,  330,  313,  331,  332,  333,  339,
+      316,  317,  320,  334,  321,  314,  315,  322,  323,  324,
+      337,  325,  340,  341,  300,  342,  343,  324,  344,  325,
+      336,  336,  336,  346,  348,  337,  329,  352,  353,  358,
+
+      359,  347,  360,  361,  331,  345,  363,  339,  356,  333,
+      328,  347,  347,  347,  330,  345,  345,  345,  345,  362,
+      364,  345,  343,  356,  332,  367,  368,  342,  334,  370,
+      366,  341,  340,  355,  355,  355,  348,  369,  344,  376,
+      358,  346,  371,  372,  374,  360,  353,  365,  365,  365,
+      352,  336,  379,  380,  361,  359,  363,  386,  799,  374,
+      396,  361,  364,  383,  365,  365,  365,  365,  381,  368,
+      365,  366,  399,  406,  362,  404,  386,  369,  387,  373,
+      367,  355,  388,  397,  370,  372,  355,  371,  355,  373,
+      373,  373,  373,  377,  376,  373,  355,  387,  389,  383,
+
+      390,  388,  379,  377,  377,  377,  377,  392,  380,  377,
+      391,  391,  393,  393,  381,  396,  398,  389,  400,  390,
+      399,  397,  402,  401,  405,  404,  392,  390,  406,  391,
+      408,  393,  410,  413,  392,  414,  415,  421,  429,  427,
+      428,  430,  431,  407,  407,  407,  432,  410,  434,  435,
+      435,  435,  436,  444,  445,  447,  400,  448,  398,  401,
+      407,  407,  407,  407,  402,  450,  407,  436,  456,  445,
+      452,  453,  448,  421,  413,  427,  414,  415,  457,  458,
+      405,  429,  428,  459,  460,  408,  463,  461,  432,  464,
+      467,  430,  438,  438,  438,  431,  444,  470,  471,  438,
+
+      472,  434,  435,  451,  477,  467,  456,  450,  447,  482,
+      435,  484,  435,  451,  451,  451,  451,  485,  452,  451,
+      486,  487,  453,  461,  488,  494,  457,  458,  466,  466,
+      466,  464,  495,  470,  471,  460,  472,  496,  459,  498,
+      503,  463,  460,  492,  492,  492,  506,  484,  499,  502,
+      504,  512,  496,  505,  511,  513,  514,  514,  514,  477,
+      488,  494,  524,  525,  482,  485,  486,  520,  520,  520,
+      526,  528,  539,  495,  487,  536,  535,  537,  537,  537,
+      543,  498,  503,  466,  537,  542,  544,  545,  548,  512,
+      492,  549,  511,  511,  563,  551,  492,  506,  499,  502,
+
+      504,  553,  553,  553,  492,  575,  505,  577,  578,  511,
+      513,  558,  558,  558,  559,  559,  559,  524,  582,  583,
+      539,  579,  584,  525,  609,  526,  528,  535,  543,  634,
+      536,  608,  544,  613,  612,  535,  563,  545,  636,  614,
+      542,  548,  565,  565,  565,  635,  656,  549,  551,  574,
+      574,  574,  593,  593,  593,  797,  553,  596,  596,  596,
+      796,  655,  583,  578,  553,  575,  558,  577,  795,  579,
+      657,  582,  612,  608,  558,  584,  613,  614,  628,  628,
+      628,  640,  640,  640,  609,  675,  677,  635,  794,  634,
+      649,  649,  649,  652,  652,  652,  574,  655,  636,  656,
+
+      676,  793,  574,  792,  574,  593,  657,  658,  658,  658,
+      574,  661,  661,  661,  697,  593,  662,  662,  662,  791,
+      596,  664,  664,  664,  666,  666,  666,  672,  672,  672,
+      673,  673,  673,  678,  678,  678,  676,  683,  683,  683,
+      675,  677,  685,  685,  685,  790,  687,  687,  687,  789,
+      788,  649,  689,  689,  689,  691,  691,  691,  694,  694,
+      694,  695,  695,  695,  787,  786,  661,  785,  783,  697,
+      782,  780,  661,  711,  711,  711,  713,  713,  713,  718,
+      718,  718,  672,  743,  743,  743,  779,  777,  672,  749,
+      749,  749,  755,  755,  755,  776,  678,  775,  774,  687,
+
+      683,  687,  757,  757,  757,  685,  762,  762,  762,  773,
+      767,  694,  764,  694,  765,  765,  765,  766,  766,  766,
+      768,  768,  768,  770,  770,  770,  711,  763,  761,  713,
+      760,  759,  718,  771,  771,  771,  772,  772,  772,  778,
+      778,  778,  758,  756,  749,  781,  781,  781,  784,  784,
+      784,  754,  753,  752,  751,  750,  748,  747,  745,  744,
+      741,  762,  740,  739,  738,  737,  736,  735,  734,  733,
+      732,  731,  766,  730,  729,  728,  727,  726,  770,  725,
+      724,  723,  722,  721,  720,  719,  717,  716,  771,  715,
+      714,  712,  778,  710,  709,  708,  707,  706,  781,  705,
+
+      704,  784,  809,  809,  809,  809,  809,  809,  810,  703,
+      810,  810,  810,  810,  810,  811,  811,  811,  811,  811,
+      812,  812,  812,  812,  812,  812,  812,  813,  813,  813,
+      813,  813,  813,  813,  814,  814,  815,  702,  701,  815,
+      816,  700,  699,  816,  698,  696,  693,  692,  690,  688,
+      686,  684,  682,  681,  680,  679,  674,  670,  669,  668,
+      667,  665,  663,  660,  659,  654,  653,  651,  650,  648,
+      646,  645,  644,  643,  642,  641,  639,  638,  637,  633,
+      632,  631,  630,  629,  627,  626,  625,  624,  623,  622,
+      621,  620,  619,  618,  617,  616,  615,  607,  606,  605,
+
+      604,  603,  602,  601,  600,  599,  598,  597,  595,  594,
+      592,  591,  590,  589,  587,  586,  585,  581,  580,  576,
+      573,  572,  571,  570,  569,  568,  567,  566,  564,  562,
+      561,  560,  557,  556,  555,  554,  552,  550,  547,  546,
+      541,  538,  534,  533,  532,  531,  530,  529,  527,  523,
+      522,  521,  519,  518,  517,  516,  515,  510,  509,  508,
+      507,  501,  500,  497,  491,  490,  489,  483,  481,  480,
+      479,  478,  476,  475,  474,  473,  469,  468,  465,  462,
+      455,  454,  449,  446,  443,  442,  441,  440,  439,  437,
+      433,  426,  425,  424,  423,  422,  420,  419,  418,  417,
+
+      416,  412,  411,  409,  403,  395,  394,  385,  382,  378,
+      375,  357,  354,  351,  349,  338,  335,  327,  326,  319,
+      305,  280,  275,  274,  269,  268,  262,  260,  259,  251,
+      250,  246,  244,  242,  241,  199,  176,  173,  165,  162,
+      149,  148,  147,  118,   98,   97,   96,   92,   74,   73,
+       71,   58,   32,   29,   26,   15,   12,   10,    9,    8,
+        3,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808,  808,  808,  808,  808,
+      808,  808,  808,  808,  808,  808
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+extern int cl2llvm_yy_flex_debug;
+int cl2llvm_yy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *cl2llvm_yytext;
+#line 1 "lex.l"
+#line 2 "lex.l"
+
+#include <math.h>
+
+#include <llvm-c/Core.h>
+
+#include "val.h"
+#include "type.h"
+#include <llvm-c/Core.h>
+#include "parser.h"
+#include "cl2llvm.h"
+
+
+
+int cl2llvm_col_num = 0;
+
+
+void cl2llvm_set_col_num(int leng)
+{
+	cl2llvm_col_num = leng;
+}
+int cl2llvm_get_col_num()
+{
+	return cl2llvm_col_num;
+}
+
+int long long unsigned htod(char *hex)
+{
+	unsigned long long decimal = 0;
+	int multval = 0;
+	int i = 0;
+	int zero_count = 2;
+	int length = strlen(hex);
+	while(hex[i+2] == '0')
+	{
+		i++;
+		zero_count++;
+	}
+	for(i = 0; i + zero_count < length; i++)
+	{
+		switch(hex[i+zero_count])
+		{
+			case'0':
+				multval = 0;
+				break;
+			case'1':
+				multval = 1;
+				break;
+			case'2':
+				multval = 2;
+				break;
+			case'3':
+				multval = 3;
+				break;
+			case'4':
+				multval = 4;
+				break;
+			case'5':
+				multval = 5;
+				break;
+			case'6':
+				multval = 6;
+				break;
+			case'7':
+				multval = 7;
+				break;
+			case'8':
+				multval = 8;
+				break;
+			case'9':
+				multval = 9;
+				break;
+			case'a':
+			case'A':
+				multval = 10;
+				break;
+			case'b':
+			case'B':
+				multval = 11;
+				break;
+			case'c':
+			case'C':
+				multval = 12;
+				break;
+			case'd':
+			case'D':
+				multval = 13;
+				break;
+			case'e':
+			case'E':
+				multval = 14;
+				break;
+			case'f':
+			case'F':
+				multval = 15;
+				break;
+			case'U':
+			case'u':
+			case'l':
+			case'L':
+				multval = 0;
+				break;
+			}
+			int place_val = i;
+			decimal = decimal + multval * pow(16, place_val);
+		}
+		return decimal;
+	}
+
+int long long unsigned otod(char *oct)
+{
+	unsigned long long decimal = 0;
+	int multval = 0;
+	int i = 0;
+	int zero_count = 1;
+	while(oct[i+1] == '0')
+	{
+		i++;
+		zero_count++;
+	}
+	int length = strlen(oct);
+	for(i = 0; i + zero_count < length; i++)
+	{
+		switch(oct[i+zero_count])
+	{
+		case'0':
+			multval = 0;
+			break;
+		case'1':
+			multval = 1;
+			break;
+		case'2':
+			multval = 2;
+			break;
+		case'3':
+			multval = 3;
+			break;
+		case'4':
+			multval = 4;
+			break;
+		case'5':
+			multval = 5;
+			break;
+		case'6':
+			multval = 6;
+			break;
+		case'7':
+			multval = 7;
+			break;			case'U':
+		case'u':
+		case'l':
+		case'L':
+			multval = 0;
+				break;
+		}
+		int place_val = i;
+		decimal = decimal + multval * pow(8, place_val);			
+	}
+	return decimal;
+}
+
+double atod(char *ascii)
+{
+	char base[100];
+	char expon[100];
+	int expon_is_neg = 0;
+
+/*	if (strlen(ascii) > 99)
+	{
+		yyerror("Constant is too large for floating point precision data type");
+	}
+*/
+	int i = 0;
+	while (ascii[i] != '\00' && ascii[i] != 'e' && ascii[i] != 'E' &&
+		ascii[i] != 'f' && ascii[i] != 'F' && ascii[i] != 'l' &&
+		ascii[i] != 'L' && ascii[i] != 'h' && ascii[i] != 'H')
+	{
+		printf("loop1\n");
+		base[i] = ascii[i];
+		i++;
+	}
+	base[i] = '\00';
+	i++;
+
+	int j = 0;
+
+	while (ascii[i] != '\00' && ascii[i] != 'f' && ascii[i] != 'F' && ascii[i] != 'l' && ascii[i] != 'L' && ascii[i] != 'h' && ascii[i] != 'H')
+	{
+		printf("loop2\n");
+		if(ascii[i] == '+')
+			i++;
+		if(ascii[i] == '-')
+		{
+			expon_is_neg = 1;
+			i++;
+		}
+		printf("%c\n", ascii[i]);
+		expon[j] = ascii[i];
+		i++;
+		j++;
+	}
+	expon[i] = '\00';
+
+	double base_d = atof(base);
+	double expon_d = atof(expon);
+	
+	if (expon_is_neg)
+		expon_d = expon_d * -1;
+	printf("base = %f, expon = %f, %d", base_d, expon_d, expon_is_neg); 
+	
+	double decimal = base_d * pow(10, expon_d);
+	printf("decimal = %f\n", decimal);
+	return decimal;
+}
+	
+#define YY_NO_INPUT 1
+#line 1350 "lex.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int cl2llvm_yylex_destroy (void );
+
+int cl2llvm_yyget_debug (void );
+
+void cl2llvm_yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE cl2llvm_yyget_extra (void );
+
+void cl2llvm_yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *cl2llvm_yyget_in (void );
+
+void cl2llvm_yyset_in  (FILE * in_str  );
+
+FILE *cl2llvm_yyget_out (void );
+
+void cl2llvm_yyset_out  (FILE * out_str  );
+
+int cl2llvm_yyget_leng (void );
+
+char *cl2llvm_yyget_text (void );
+
+int cl2llvm_yyget_lineno (void );
+
+void cl2llvm_yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int cl2llvm_yywrap (void );
+#else
+extern int cl2llvm_yywrap (void );
+#endif
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( cl2llvm_yytext, cl2llvm_yyleng, 1, cl2llvm_yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		size_t n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( cl2llvm_yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( cl2llvm_yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, cl2llvm_yyin))==0 && ferror(cl2llvm_yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(cl2llvm_yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int cl2llvm_yylex (void);
+
+#define YY_DECL int cl2llvm_yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after cl2llvm_yytext and cl2llvm_yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 384 "lex.l"
+
+
+#line 1538 "lex.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! cl2llvm_yyin )
+			cl2llvm_yyin = stdin;
+
+		if ( ! cl2llvm_yyout )
+			cl2llvm_yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			cl2llvm_yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				cl2llvm_yy_create_buffer(cl2llvm_yyin,YY_BUF_SIZE );
+		}
+
+		cl2llvm_yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of cl2llvm_yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 809 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 1662 );
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+		if ( yy_act == 0 )
+			{ /* have to back up */
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			yy_act = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+/* rule 1 can match eol */
+YY_RULE_SETUP
+#line 386 "lex.l"
+{ 
+	cl2llvm_yyset_lineno(cl2llvm_yyget_lineno() + 1);
+	cl2llvm_set_col_num(0);
+}
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 392 "lex.l"
+{
+}
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+#line 395 "lex.l"
+{
+}
+	YY_BREAK
+case 4:
+/* rule 4 can match eol */
+YY_RULE_SETUP
+#line 398 "lex.l"
+{
+	printf("STRING - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_STRING;
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 403 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val = htod(cl2llvm_yytext);
+	printf("hex in dec = %ld\n", cl2llvm_yylval.const_int_val);
+	return TOK_CONST_INT;
+}
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 410 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL_U - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val = htod(cl2llvm_yytext);
+	printf("hex in dec = %ld\n", cl2llvm_yylval.const_int_val);
+	return TOK_CONST_INT_U;
+}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 417 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL_L - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val = htod(cl2llvm_yytext);
+	printf("hex in dec = %ld\n", cl2llvm_yylval.const_int_val);
+	return TOK_CONST_INT_L;
+}
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 424 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL_LL - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val_ull = htod(cl2llvm_yytext);
+	printf("hex in dec = %llu\n", cl2llvm_yylval.const_int_val_ull);
+	return TOK_CONST_INT_LL;
+}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+#line 431 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL_UL - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val = htod(cl2llvm_yytext);
+	printf("hex in dec = %ld\n", cl2llvm_yylval.const_int_val);
+	return TOK_CONST_INT_UL;
+}
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 438 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_INT_ULL - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val_ull = htod(cl2llvm_yytext);
+	printf("hex in dec = %llu\n", cl2llvm_yylval.const_int_val_ull);
+	return TOK_CONST_INT_ULL;
+}
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 445 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val = otod(cl2llvm_yytext);
+	printf("oct in dec = %ld\n", cl2llvm_yylval.const_int_val);
+	return TOK_CONST_INT;
+}
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 452 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val = atoi(cl2llvm_yytext);
+	return TOK_CONST_INT;
+}
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 458 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL_U - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val = atoi(cl2llvm_yytext);
+	return TOK_CONST_INT_U;
+}
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 464 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL_L - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val = atoi(cl2llvm_yytext);
+	return TOK_CONST_INT_L;
+}
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 470 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL_UL - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val = atoi(cl2llvm_yytext);
+	return TOK_CONST_INT_UL;
+}
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+#line 476 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL_LL - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val_ull = atoi(cl2llvm_yytext);
+	return TOK_CONST_INT_LL;
+}
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 482 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL_ULL - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.const_int_val_ull = atoi(cl2llvm_yytext);
+	return TOK_CONST_INT_ULL;
+}
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 488 "lex.l"
+{
+	printf("TOK_CONST_DEC_EX - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	cl2llvm_yylval.const_float_val = atod(cl2llvm_yytext);
+	return TOK_CONST_DEC;
+}
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 494 "lex.l"
+{
+	printf("TOK_CONST_DEC_EX - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	cl2llvm_yylval.const_float_val = atod(cl2llvm_yytext);
+	return TOK_CONST_DEC;
+}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 500 "lex.l"
+{
+	printf("TOK_CONST_VAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	cl2llvm_yylval.const_float_val = atod(cl2llvm_yytext);
+	return TOK_CONST_DEC_H;
+}
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 506 "lex.l"
+{
+	printf("TOK_CONST_VAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	cl2llvm_yylval.const_float_val = atod(cl2llvm_yytext);
+	return TOK_CONST_DEC_F;
+}
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 512 "lex.l"
+{
+	printf("TOK_CONST_VAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	cl2llvm_yylval.const_float_val = atod(cl2llvm_yytext);
+	return TOK_CONST_DEC_L;
+}
+	YY_BREAK
+case 23:
+/* rule 23 can match eol */
+YY_RULE_SETUP
+#line 518 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_CONST_VAL - %s\n", cl2llvm_yytext);
+	return TOK_CONST_VAL;
+}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 523 "lex.l"
+{
+	printf("COMMA - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_COMMA;
+}
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 528 "lex.l"
+{
+	printf("TOK_SEMICOLON - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_SEMICOLON;
+}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+#line 533 "lex.l"
+{
+	printf("TOK_COLON - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_COLON;
+}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 538 "lex.l"
+{
+	printf("TOK_PAR_OPEN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_PAR_OPEN;
+}
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 543 "lex.l"
+{
+	printf("TOK_PAR_CLOSE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_PAR_CLOSE;
+}
+	YY_BREAK
+case 29:
+YY_RULE_SETUP
+#line 548 "lex.l"
+{
+	printf("BRACKET_OPEN %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_BRACKET_OPEN;
+}
+	YY_BREAK
+case 30:
+YY_RULE_SETUP
+#line 553 "lex.l"
+{
+	printf("TOK_BRACKET_CLOSE %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_BRACKET_CLOSE;
+}
+	YY_BREAK
+case 31:
+YY_RULE_SETUP
+#line 558 "lex.l"
+{
+	printf("TOK_CURLY_BRACE_OPEN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_CURLY_BRACE_OPEN;
+}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+#line 563 "lex.l"
+{
+	printf("TOK_CURLY_BRACE_CLOSE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_CURLY_BRACE_CLOSE;
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+#line 569 "lex.l"
+{
+	printf("TOK_PLUS - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_PLUS;
+}
+	YY_BREAK
+case 34:
+YY_RULE_SETUP
+#line 575 "lex.l"
+{
+	printf("TOK_MINUS - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_MINUS;
+}
+	YY_BREAK
+case 35:
+YY_RULE_SETUP
+#line 580 "lex.l"
+{
+	printf("TOK_MULT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_MULT;
+}
+	YY_BREAK
+case 36:
+YY_RULE_SETUP
+#line 585 "lex.l"
+{
+	printf("TOK_DIV - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_DIV;
+}
+	YY_BREAK
+case 37:
+YY_RULE_SETUP
+#line 590 "lex.l"
+{
+	printf("TOK_MOD - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_MOD;
+}
+	YY_BREAK
+case 38:
+YY_RULE_SETUP
+#line 595 "lex.l"
+{
+	printf("TOK_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_EQUAL;
+}
+	YY_BREAK
+case 39:
+YY_RULE_SETUP
+#line 600 "lex.l"
+{
+	printf("TOK_ELLIPSIS - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 3);
+	return TOK_ELLIPSIS;
+}
+	YY_BREAK
+case 40:
+YY_RULE_SETUP
+#line 605 "lex.l"
+{
+	printf("TOK_ADD_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_ADD_EQUAL;
+}
+	YY_BREAK
+case 41:
+YY_RULE_SETUP
+#line 610 "lex.l"
+{
+	printf("TOK_MINUS_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_MINUS_EQUAL;
+}
+	YY_BREAK
+case 42:
+YY_RULE_SETUP
+#line 615 "lex.l"
+{
+	printf("TOK_MULT_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_MULT_EQUAL;
+}
+	YY_BREAK
+case 43:
+YY_RULE_SETUP
+#line 620 "lex.l"
+{
+	printf("TOK_DIV_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_DIV_EQUAL;
+}
+	YY_BREAK
+case 44:
+YY_RULE_SETUP
+#line 625 "lex.l"
+{
+	printf("TOK_MOD_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_MOD_EQUAL;
+}
+	YY_BREAK
+case 45:
+YY_RULE_SETUP
+#line 630 "lex.l"
+{
+	printf("TOK_AND_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_AND_EQUAL;
+}
+	YY_BREAK
+case 46:
+YY_RULE_SETUP
+#line 635 "lex.l"
+{
+	printf("TOK_OR_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_OR_EQUAL;
+}
+	YY_BREAK
+case 47:
+YY_RULE_SETUP
+#line 640 "lex.l"
+{
+	printf("TOK_EXCLUSIVE_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_EXCLUSIVE_EQUAL;
+}
+	YY_BREAK
+case 48:
+YY_RULE_SETUP
+#line 645 "lex.l"
+{
+	printf("TOK_SHIFT_LEFT_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 3);
+	return TOK_SHIFT_RIGHT_EQUAL;
+}
+	YY_BREAK
+case 49:
+YY_RULE_SETUP
+#line 650 "lex.l"
+{
+	printf("TOK_SHIFT_LEFT_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 3);
+	return TOK_SHIFT_LEFT_EQUAL;
+}
+	YY_BREAK
+case 50:
+YY_RULE_SETUP
+#line 655 "lex.l"
+{
+	printf("TOK_GREATER - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_GREATER;
+}
+	YY_BREAK
+case 51:
+YY_RULE_SETUP
+#line 660 "lex.l"
+{
+	printf("TOK_LESS - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_LESS;
+}
+	YY_BREAK
+case 52:
+YY_RULE_SETUP
+#line 665 "lex.l"
+{
+	printf("TOK_INCREMENT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_INCREMENT;
+}
+	YY_BREAK
+case 53:
+YY_RULE_SETUP
+#line 670 "lex.l"
+{
+	printf("TOK_DECREMENT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_DECREMENT;
+}
+	YY_BREAK
+case 54:
+YY_RULE_SETUP
+#line 675 "lex.l"
+{
+	printf("TOK_SHIFT_LEFT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_SHIFT_LEFT;
+}
+	YY_BREAK
+case 55:
+YY_RULE_SETUP
+#line 680 "lex.l"
+{
+	printf("TOK_SHIFT_RIGHT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_SHIFT_RIGHT;
+}
+	YY_BREAK
+case 56:
+YY_RULE_SETUP
+#line 685 "lex.l"
+{
+	printf("TOK_CONDTIONAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_CONDITIONAL;
+}
+	YY_BREAK
+case 57:
+YY_RULE_SETUP
+#line 690 "lex.l"
+{
+	printf("TOK_BITWISE_NOT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_BITWISE_NOT;
+}
+	YY_BREAK
+case 58:
+YY_RULE_SETUP
+#line 695 "lex.l"
+{
+	printf("TOK_BITWISE_EXCLUSIVE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_BITWISE_EXCLUSIVE;
+}
+	YY_BREAK
+case 59:
+YY_RULE_SETUP
+#line 700 "lex.l"
+{
+	printf("TOK_BITWISE_OR - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_BITWISE_OR;
+}
+	YY_BREAK
+case 60:
+YY_RULE_SETUP
+#line 705 "lex.l"
+{
+	printf("TOK_BITWISE_AND - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_BITWISE_AND;
+}
+	YY_BREAK
+case 61:
+YY_RULE_SETUP
+#line 710 "lex.l"
+{
+	printf("TOK_LOGICAL_AND -  %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_LOGICAL_AND;
+}
+	YY_BREAK
+case 62:
+YY_RULE_SETUP
+#line 715 "lex.l"
+{
+	printf("TOK_LOGICAL_OR - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_LOGICAL_OR;
+}
+	YY_BREAK
+case 63:
+YY_RULE_SETUP
+#line 720 "lex.l"
+{
+	printf("TOK_LOGICAL_NEGATE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_LOGICAL_NEGATE;
+}
+	YY_BREAK
+case 64:
+YY_RULE_SETUP
+#line 726 "lex.l"
+{
+	printf("TOK_GREATER_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_GREATER_EQUAL;
+}
+	YY_BREAK
+case 65:
+YY_RULE_SETUP
+#line 731 "lex.l"
+{
+	printf("TOK_LESS_EQUAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_LESS_EQUAL;
+}
+	YY_BREAK
+case 66:
+YY_RULE_SETUP
+#line 736 "lex.l"
+{
+	printf("TOK_EQUALITY - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_EQUALITY;
+}
+	YY_BREAK
+case 67:
+YY_RULE_SETUP
+#line 741 "lex.l"
+{
+	printf("TOK_INEQUALITY - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_INEQUALITY;
+}
+	YY_BREAK
+case 68:
+YY_RULE_SETUP
+#line 746 "lex.l"
+{
+	printf("TOK_STRUCT_REF - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	return TOK_STRUCT_REF;
+}
+	YY_BREAK
+case 69:
+YY_RULE_SETUP
+#line 751 "lex.l"
+{
+	printf("TOK_STRUCT_DEREF - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_STRUCT_DEREF;
+}
+	YY_BREAK
+case 70:
+YY_RULE_SETUP
+#line 756 "lex.l"
+{
+	printf("TOK_AUTO - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 4);
+	return TOK_AUTO;
+}
+	YY_BREAK
+case 71:
+YY_RULE_SETUP
+#line 761 "lex.l"
+{
+	printf("TOK_BOOL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 4);
+	return TOK_BOOL;
+}
+	YY_BREAK
+case 72:
+YY_RULE_SETUP
+#line 766 "lex.l"
+{
+	printf("TOK_BREAK - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 5);
+	return TOK_BREAK;
+}
+	YY_BREAK
+case 73:
+YY_RULE_SETUP
+#line 771 "lex.l"
+{
+	printf("TOK_CASE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 4);
+	return TOK_CASE;
+}
+	YY_BREAK
+case 74:
+/* rule 74 can match eol */
+YY_RULE_SETUP
+#line 776 "lex.l"
+{
+	printf("TOK_CHAR - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 4);
+	return TOK_CHAR;
+}
+	YY_BREAK
+case 75:
+YY_RULE_SETUP
+#line 781 "lex.l"
+{
+	printf("TOK_CHARN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_CHARN;
+}
+	YY_BREAK
+case 76:
+YY_RULE_SETUP
+#line 786 "lex.l"
+{
+	printf("TOK_CONSTANT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 8);
+	return TOK_CONSTANT;
+}
+	YY_BREAK
+case 77:
+YY_RULE_SETUP
+#line 791 "lex.l"
+{
+	printf("TOK_CONST - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 5);
+	return TOK_CONST;
+}
+	YY_BREAK
+case 78:
+YY_RULE_SETUP
+#line 796 "lex.l"
+{
+	printf("TOK_CONTINUE - %s\n",cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 8);
+	return TOK_CONTINUE;
+}
+	YY_BREAK
+case 79:
+YY_RULE_SETUP
+#line 801 "lex.l"
+{
+	printf("TOK_DEFAULT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 7);
+	return TOK_DEFAULT;
+}
+	YY_BREAK
+case 80:
+YY_RULE_SETUP
+#line 806 "lex.l"
+{
+	printf("TOK_DO - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_DO;
+}
+	YY_BREAK
+case 81:
+YY_RULE_SETUP
+#line 811 "lex.l"
+{
+	printf("TOK_DOUBLE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 6);
+	return TOK_DOUBLE;
+}
+	YY_BREAK
+case 82:
+/* rule 82 can match eol */
+YY_RULE_SETUP
+#line 816 "lex.l"
+{
+	printf("TOK_DOUBLE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_DOUBLE_LONG;
+}
+	YY_BREAK
+case 83:
+YY_RULE_SETUP
+#line 821 "lex.l"
+{
+	printf("TOK_CHARN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_DOUBLEN;
+}
+	YY_BREAK
+case 84:
+YY_RULE_SETUP
+#line 826 "lex.l"
+{
+	printf("TOK_ESLE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 4);
+	return TOK_ELSE;
+}
+	YY_BREAK
+case 85:
+YY_RULE_SETUP
+#line 831 "lex.l"
+{
+	printf("TOK_ENUM - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 4);
+	return TOK_ENUM;
+}
+	YY_BREAK
+case 86:
+YY_RULE_SETUP
+#line 836 "lex.l"
+{
+	printf("TOK_EVENT_T - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 7);
+	return TOK_EVENT_T;
+}
+	YY_BREAK
+case 87:
+YY_RULE_SETUP
+#line 841 "lex.l"
+{
+	printf("TOK_EXTERN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 6);
+	return TOK_EXTERN;
+}
+	YY_BREAK
+case 88:
+YY_RULE_SETUP
+#line 846 "lex.l"
+{
+	printf("TOK_FLOAT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 5);
+	return TOK_FLOAT;
+}
+	YY_BREAK
+case 89:
+YY_RULE_SETUP
+#line 851 "lex.l"
+{
+	printf("TOK_FLOATN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_FLOATN;
+}
+	YY_BREAK
+case 90:
+YY_RULE_SETUP
+#line 856 "lex.l"
+{
+	printf("TOK_FOR - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 3);
+	return TOK_FOR;
+}
+	YY_BREAK
+case 91:
+YY_RULE_SETUP
+#line 861 "lex.l"
+{
+	printf("TOK_GLOBAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_GLOBAL;
+}
+	YY_BREAK
+case 92:
+YY_RULE_SETUP
+#line 866 "lex.l"
+{
+	printf("TOK_GOTO - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 4);
+	return TOK_GOTO;
+}
+	YY_BREAK
+case 93:
+YY_RULE_SETUP
+#line 871 "lex.l"
+{
+	printf("TOK_HALF - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 4);
+	return TOK_HALF;
+}
+	YY_BREAK
+case 94:
+YY_RULE_SETUP
+#line 876 "lex.l"
+{
+	printf("TOK_IF - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 2);
+	return TOK_IF;
+}
+	YY_BREAK
+case 95:
+YY_RULE_SETUP
+#line 881 "lex.l"
+{
+	printf("TOK_IMAGE2D_T - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 9);
+	return TOK_IMAGE2D_T;
+}
+	YY_BREAK
+case 96:
+YY_RULE_SETUP
+#line 886 "lex.l"
+{
+	printf("TOK_IMAGE3D_T - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 9);
+	return TOK_IMAGE3D_T;
+}
+	YY_BREAK
+case 97:
+YY_RULE_SETUP
+#line 891 "lex.l"
+{
+	printf("TOK_IMAGE2D_ARRAY_T - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 15);
+	return TOK_IMAGE2D_ARRAY_T;
+}
+	YY_BREAK
+case 98:
+YY_RULE_SETUP
+#line 896 "lex.l"
+{
+	printf("TOK_IMAGE1D_T - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 9);
+	return TOK_IMAGE1D_T;
+}
+	YY_BREAK
+case 99:
+YY_RULE_SETUP
+#line 901 "lex.l"
+{
+	printf("TOK_IMAGE1D_BUFFER_T - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 16);
+	return TOK_IMAGE1D_BUFFER_T;
+}
+	YY_BREAK
+case 100:
+YY_RULE_SETUP
+#line 906 "lex.l"
+{
+	printf("TOK_IMAGE1D_ARRAY_T - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 15);
+	return TOK_IMAGE1D_ARRAY_T;
+}
+	YY_BREAK
+case 101:
+YY_RULE_SETUP
+#line 911 "lex.l"
+{
+	printf("TOK_INLINE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 6);
+	return TOK_INLINE;
+}
+	YY_BREAK
+case 102:
+/* rule 102 can match eol */
+YY_RULE_SETUP
+#line 916 "lex.l"
+{
+	printf("TOK_INT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 3);
+	return TOK_INT;
+}
+	YY_BREAK
+case 103:
+YY_RULE_SETUP
+#line 921 "lex.l"
+{
+	printf("TOK_INTN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_INTN;
+}
+	YY_BREAK
+case 104:
+YY_RULE_SETUP
+#line 926 "lex.l"
+{
+	printf("TOK_INTPTR_T - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 8);
+	return TOK_INTPTR_T;
+}
+	YY_BREAK
+case 105:
+YY_RULE_SETUP
+#line 931 "lex.l"
+{
+	printf("TOK_KERNEL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_KERNEL;
+}
+	YY_BREAK
+case 106:
+YY_RULE_SETUP
+#line 936 "lex.l"
+{
+	printf("TOK_LOCAL - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 5);
+	return TOK_LOCAL;
+}
+	YY_BREAK
+case 107:
+/* rule 107 can match eol */
+YY_RULE_SETUP
+#line 941 "lex.l"
+{
+	printf("TOK_LONG - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 4);
+	return TOK_LONG;
+}
+	YY_BREAK
+case 108:
+/* rule 108 can match eol */
+YY_RULE_SETUP
+#line 946 "lex.l"
+{
+	printf("TOK_LONG_LONG - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_LONG_LONG;
+}
+	YY_BREAK
+case 109:
+YY_RULE_SETUP
+#line 951 "lex.l"
+{
+	printf("TOK_LONGN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_LONGN;
+}
+	YY_BREAK
+case 110:
+YY_RULE_SETUP
+#line 956 "lex.l"
+{
+	printf("TOK_PRIVATE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 7);
+	return TOK_PRIVATE;
+}
+	YY_BREAK
+case 111:
+YY_RULE_SETUP
+#line 961 "lex.l"
+{
+	printf("TOK_PTRDIFF_T - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 9);
+	return TOK_PTRDIFF_T;
+}
+	YY_BREAK
+case 112:
+YY_RULE_SETUP
+#line 966 "lex.l"
+{
+	printf("TOK_REGISTER - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 8);
+	return TOK_REGISTER;
+}
+	YY_BREAK
+case 113:
+YY_RULE_SETUP
+#line 971 "lex.l"
+{
+	printf("TOK_RETURN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 6);
+	return TOK_RETURN;
+}
+	YY_BREAK
+case 114:
+YY_RULE_SETUP
+#line 976 "lex.l"
+{
+	printf("TOK_SAMPLER_T - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 9);
+	return TOK_SAMPLER_T;
+}
+	YY_BREAK
+case 115:
+/* rule 115 can match eol */
+YY_RULE_SETUP
+#line 981 "lex.l"
+{
+	printf("TOK_SHORT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 5);
+	return TOK_SHORT;
+}
+	YY_BREAK
+case 116:
+YY_RULE_SETUP
+#line 986 "lex.l"
+{
+	printf("TOK_SHORTN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_SHORTN;
+}
+	YY_BREAK
+case 117:
+YY_RULE_SETUP
+#line 991 "lex.l"
+{
+	printf("TOK_SIZEOF - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 6);
+	return TOK_SIZEOF;
+}
+	YY_BREAK
+case 118:
+YY_RULE_SETUP
+#line 996 "lex.l"
+{
+	printf("TOK_SIZE_T - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 6);
+	return TOK_SIZE_T;
+}
+	YY_BREAK
+case 119:
+YY_RULE_SETUP
+#line 1001 "lex.l"
+{
+	printf("TOK_STATIC - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 6);
+	return TOK_STATIC;
+}
+	YY_BREAK
+case 120:
+YY_RULE_SETUP
+#line 1006 "lex.l"
+{
+	printf("TOK_STRUCT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 6);
+	return TOK_STRUCT;
+}
+	YY_BREAK
+case 121:
+YY_RULE_SETUP
+#line 1011 "lex.l"
+{
+	printf("TOK_SWITCH - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 6);
+	return TOK_SWITCH;
+}
+	YY_BREAK
+case 122:
+YY_RULE_SETUP
+#line 1016 "lex.l"
+{
+	printf("TOK_TYPEDEF - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 7);
+	return TOK_TYPEDEF;
+}
+	YY_BREAK
+case 123:
+/* rule 123 can match eol */
+YY_RULE_SETUP
+#line 1021 "lex.l"
+{
+	printf("TOK_TYPENAME - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 4);
+	return TOK_TYPENAME;
+}
+	YY_BREAK
+case 124:
+/* rule 124 can match eol */
+YY_RULE_SETUP
+#line 1026 "lex.l"
+{
+	printf("TOK_UNSIGNED TOK_CHAR - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 5);
+	return TOK_UCHAR;
+}
+	YY_BREAK
+case 125:
+YY_RULE_SETUP
+#line 1031 "lex.l"
+{
+	printf("TOK_UCHARN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_UCHARN;
+}
+	YY_BREAK
+case 126:
+/* rule 126 can match eol */
+YY_RULE_SETUP
+#line 1036 "lex.l"
+{
+	printf("TOK_UNSIGNED TOK_INT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 4);
+	return TOK_UINT;
+}
+	YY_BREAK
+case 127:
+/* rule 127 can match eol */
+YY_RULE_SETUP
+#line 1041 "lex.l"
+{
+	printf("TOK_UINT_LONG - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_UINT_LONG;
+}
+	YY_BREAK
+case 128:
+/* rule 128 can match eol */
+YY_RULE_SETUP
+#line 1046 "lex.l"
+{
+	printf("TOK_UINT_LONG_LONG - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_UINT_LONG_LONG;
+}
+	YY_BREAK
+case 129:
+YY_RULE_SETUP
+#line 1051 "lex.l"
+{
+	printf("TOK_UINTN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_UINTN;
+}
+	YY_BREAK
+case 130:
+YY_RULE_SETUP
+#line 1056 "lex.l"
+{
+	printf("TOK_UINTPTR_T - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 9);
+	return TOK_UINTPTR_T;
+}
+	YY_BREAK
+case 131:
+YY_RULE_SETUP
+#line 1061 "lex.l"
+{
+	printf("TOK_ULONGN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_ULONGN;
+}
+	YY_BREAK
+case 132:
+YY_RULE_SETUP
+#line 1066 "lex.l"
+{
+	printf("TOK_UNION - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 5);
+	return TOK_UNION;
+}
+	YY_BREAK
+case 133:
+/* rule 133 can match eol */
+YY_RULE_SETUP
+#line 1071 "lex.l"
+{
+	printf("TOK_UNSIGNED TOK_SHORT - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 6);
+	return TOK_USHORT;
+}
+	YY_BREAK
+case 134:
+YY_RULE_SETUP
+#line 1076 "lex.l"
+{
+	printf("TOK_USHORTN - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	return TOK_USHORTN;
+}
+	YY_BREAK
+case 135:
+YY_RULE_SETUP
+#line 1081 "lex.l"
+{
+	printf("TOK_VOID - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 4);
+	return TOK_VOID;
+}
+	YY_BREAK
+case 136:
+YY_RULE_SETUP
+#line 1086 "lex.l"
+{
+	printf("TOK_READ_ONLY - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 9);
+	return TOK_READ_ONLY;
+}
+	YY_BREAK
+case 137:
+YY_RULE_SETUP
+#line 1091 "lex.l"
+{
+	printf("TOK_WRITE_ONLY - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 10);
+	return TOK_WRITE_ONLY;
+}
+	YY_BREAK
+case 138:
+YY_RULE_SETUP
+#line 1096 "lex.l"
+{
+	printf("TOK_READ_WRITE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 10);
+	return TOK_READ_WRITE;
+}
+	YY_BREAK
+case 139:
+YY_RULE_SETUP
+#line 1101 "lex.l"
+{
+	printf("TOK_VOLATILE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 8);
+	return TOK_VOLATILE;
+}
+	YY_BREAK
+case 140:
+YY_RULE_SETUP
+#line 1106 "lex.l"
+{
+	printf("TOK_WHILE - %s\n", cl2llvm_yytext);
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 5);
+	return TOK_WHILE;
+}
+	YY_BREAK
+case 141:
+YY_RULE_SETUP
+#line 1113 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + cl2llvm_yyget_leng());
+	printf("TOK_ID - %s\n", cl2llvm_yytext);
+	cl2llvm_yylval.identifier = strdup(cl2llvm_yytext);
+	return TOK_ID;
+}
+	YY_BREAK
+case 142:
+YY_RULE_SETUP
+#line 1119 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+}
+	YY_BREAK
+case 143:
+YY_RULE_SETUP
+#line 1122 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 8);
+}
+	YY_BREAK
+case 144:
+YY_RULE_SETUP
+#line 1127 "lex.l"
+{
+	cl2llvm_set_col_num(cl2llvm_get_col_num() + 1);
+	cl2llvm_yyerror_fmt("unexpected symbol '%s'", cl2llvm_yytext);
+}
+	YY_BREAK
+case 145:
+YY_RULE_SETUP
+#line 1132 "lex.l"
+ECHO;
+	YY_BREAK
+#line 2953 "lex.c"
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed cl2llvm_yyin at a new source and called
+			 * cl2llvm_yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = cl2llvm_yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( cl2llvm_yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * cl2llvm_yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of cl2llvm_yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					cl2llvm_yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			cl2llvm_yyrestart(cl2llvm_yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) cl2llvm_yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 809 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	register YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 809 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 808);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					cl2llvm_yyrestart(cl2llvm_yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( cl2llvm_yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve cl2llvm_yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void cl2llvm_yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        cl2llvm_yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            cl2llvm_yy_create_buffer(cl2llvm_yyin,YY_BUF_SIZE );
+	}
+
+	cl2llvm_yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	cl2llvm_yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void cl2llvm_yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		cl2llvm_yypop_buffer_state();
+	 *		cl2llvm_yypush_buffer_state(new_buffer);
+     */
+	cl2llvm_yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	cl2llvm_yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (cl2llvm_yywrap()) processing, but the only time this flag
+	 * is looked at is after cl2llvm_yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void cl2llvm_yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	cl2llvm_yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE cl2llvm_yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) cl2llvm_yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in cl2llvm_yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) cl2llvm_yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in cl2llvm_yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	cl2llvm_yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with cl2llvm_yy_create_buffer()
+ * 
+ */
+    void cl2llvm_yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		cl2llvm_yyfree((void *) b->yy_ch_buf  );
+
+	cl2llvm_yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a cl2llvm_yyrestart() or at EOF.
+ */
+    static void cl2llvm_yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	cl2llvm_yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then cl2llvm_yy_init_buffer was _probably_
+     * called from cl2llvm_yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void cl2llvm_yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		cl2llvm_yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void cl2llvm_yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	cl2llvm_yyensure_buffer_stack();
+
+	/* This block is copied from cl2llvm_yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from cl2llvm_yy_switch_to_buffer. */
+	cl2llvm_yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void cl2llvm_yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	cl2llvm_yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		cl2llvm_yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void cl2llvm_yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)cl2llvm_yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in cl2llvm_yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)cl2llvm_yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in cl2llvm_yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE cl2llvm_yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) cl2llvm_yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in cl2llvm_yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	cl2llvm_yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to cl2llvm_yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       cl2llvm_yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE cl2llvm_yy_scan_string (yyconst char * yystr )
+{
+    
+	return cl2llvm_yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to cl2llvm_yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE cl2llvm_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) cl2llvm_yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in cl2llvm_yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = cl2llvm_yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in cl2llvm_yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up cl2llvm_yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		cl2llvm_yytext[cl2llvm_yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = cl2llvm_yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		cl2llvm_yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int cl2llvm_yyget_lineno  (void)
+{
+        
+    return cl2llvm_yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *cl2llvm_yyget_in  (void)
+{
+        return cl2llvm_yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *cl2llvm_yyget_out  (void)
+{
+        return cl2llvm_yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int cl2llvm_yyget_leng  (void)
+{
+        return cl2llvm_yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *cl2llvm_yyget_text  (void)
+{
+        return cl2llvm_yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void cl2llvm_yyset_lineno (int  line_number )
+{
+    
+    cl2llvm_yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see cl2llvm_yy_switch_to_buffer
+ */
+void cl2llvm_yyset_in (FILE *  in_str )
+{
+        cl2llvm_yyin = in_str ;
+}
+
+void cl2llvm_yyset_out (FILE *  out_str )
+{
+        cl2llvm_yyout = out_str ;
+}
+
+int cl2llvm_yyget_debug  (void)
+{
+        return cl2llvm_yy_flex_debug;
+}
+
+void cl2llvm_yyset_debug (int  bdebug )
+{
+        cl2llvm_yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from cl2llvm_yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    cl2llvm_yyin = stdin;
+    cl2llvm_yyout = stdout;
+#else
+    cl2llvm_yyin = (FILE *) 0;
+    cl2llvm_yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * cl2llvm_yylex_init()
+     */
+    return 0;
+}
+
+/* cl2llvm_yylex_destroy is for both reentrant and non-reentrant scanners. */
+int cl2llvm_yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		cl2llvm_yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		cl2llvm_yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	cl2llvm_yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * cl2llvm_yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *cl2llvm_yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *cl2llvm_yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void cl2llvm_yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see cl2llvm_yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 1132 "lex.l"
+
+
+
+
